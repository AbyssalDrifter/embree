// ======================================================================== //
// Copyright 2009-2017 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

#ifndef __RTCORE_ISPH__
#define __RTCORE_ISPH__

#include "rtcore_version.h"

/* This is necessary as the size_t type under ISPC may be 32 or 64 bits wide depending on the ISPC addressing mode used. */
#if !defined(size_t) // FIXME: have to undefine these again
#define size_t uintptr_t
#define ssize_t intptr_t
#endif

#if !defined(RTCORE_API)
#define RTCORE_API extern "C" unmasked
#endif

#ifdef _WIN32
#  define RTCORE_ALIGN(...) // FIXME: need to specify alignment
#else
#  define RTCORE_ALIGN(...) // FIXME: need to specify alignment
#endif

#if !defined(RTCORE_DEPRECATED)
#define RTCORE_DEPRECATED // FIXME: deprecation not supported by ISPC
#endif

#if !defined(RTCORE_FORCEINLINE)
#define RTCORE_FORCEINLINE inline
#endif

/*! \file rtcore.isph Defines the Embree Ray Tracing Kernel API for ISPC.

   This file defines the Embree ray tracing kernel API for C and
   C++. The user is supposed to include this file, and alternatively
   the rtcore_ray.isph file, but none of the other .isph files in this
   folder. */

/*! \{ */

/*! Axis aligned bounding box representation */
RTCORE_ALIGN(16) struct RTCBounds
{
  float lower_x, lower_y, lower_z, align0;
  float upper_x, upper_y, upper_z, align1;
};

/*! \brief Defines an opaque device type */
typedef uniform struct __RTCDevice* uniform RTCDevice;

/*! \brief Creates a new Embree device.

  Creates a new Embree device to be used by the application. An
  application typically creates only a single Embree device, but it is
  valid to use multiple devices inside an application. A configuration
  string can be passed at construction time, that allows to configure
  implementation specific parameters. If this string is NULL, a
  default configuration is used. The following configuration flags are
  supported by the Embree implementation of the API:
  
  verbose = num,       // sets verbosity level (default is 0)

  If Embree is started on an unsupported CPU, rtcNewDevice will fail and
  set the RTC_UNSUPPORTED_CPU error code.
  
*/
RTCORE_API RTCDevice rtcNewDevice(const uniform int8* uniform cfg = NULL);

/*! \brief Deletes an Embree device.

  Deletes the Embree device again. After deletion, all scene handles
  are invalid. */
RTCORE_API void rtcDeleteDevice(RTCDevice device);

/*! \brief Parameters that can get configured using the rtcSetParameter functions. */
enum RTCParameter {
  RTC_SOFTWARE_CACHE_SIZE = 0,                /*! Configures the software cache size (used
                                                to cache subdivision surfaces for
                                                instance). The size is specified as an
                                                integer number of bytes. The software
                                                cache cannot be configured during
                                                rendering. (write only) */

  RTC_CONFIG_INTERSECT1 = 1,                  //!< checks if rtcIntersect1 is supported (read only)
  RTC_CONFIG_INTERSECT4 = 2,                  //!< checks if rtcIntersect4 is supported (read only)
  RTC_CONFIG_INTERSECT8 = 3,                  //!< checks if rtcIntersect8 is supported (read only)
  RTC_CONFIG_INTERSECT16 = 4,                 //!< checks if rtcIntersect16 is supported (read only)
  RTC_CONFIG_INTERSECT_STREAM = 5,            //!< checks if rtcIntersect1M, rtcIntersectVM, rtcIntersectNM and rtcIntersectNp are supported (read only)

  RTC_CONFIG_RAY_MASK = 6,                    //!< checks if ray masks are supported (read only)
  RTC_CONFIG_BACKFACE_CULLING = 7,            //!< checks if backface culling is supported (read only)
  RTC_CONFIG_INTERSECTION_FILTER = 8,         //!< checks if intersection filters are enabled (read only)
  RTC_CONFIG_INTERSECTION_FILTER_RESTORE = 9, //!< checks if intersection filters restores previous hit (read only)
  RTC_CONFIG_IGNORE_INVALID_RAYS = 11,        //!< checks if invalid rays are ignored (read only)
  RTC_CONFIG_TASKING_SYSTEM = 12,             //!< return used tasking system (0 = INTERNAL, 1 = TBB) (read only)
  
  RTC_CONFIG_VERSION_MAJOR = 13,           //!< returns Embree major version (read only)
  RTC_CONFIG_VERSION_MINOR = 14,           //!< returns Embree minor version (read only)
  RTC_CONFIG_VERSION_PATCH = 15,           //!< returns Embree patch version (read only)
  RTC_CONFIG_VERSION = 16,                 //!< returns Embree version as integer (e.g. Embree v2.8.2 -> 20802) (read only)

  RTC_CONFIG_TRIANGLE_GEOMETRY = 17,         //!< checks if triangle geometries are supported
  RTC_CONFIG_QUAD_GEOMETRY = 18,             //!< checks if quad geometries are supported
  RTC_CONFIG_LINE_GEOMETRY = 19,             //!< checks if line geometries are supported
  RTC_CONFIG_HAIR_GEOMETRY = 20,              //!< checks if hair geometries are supported
  RTC_CONFIG_SUBDIV_GEOMETRY = 21,           //!< checks if subdiv geometries are supported
  RTC_CONFIG_USER_GEOMETRY = 22,             //!< checks if user geometries are supported

  RTC_CONFIG_COMMIT_JOIN = 23,               //!< checks if rtcCommitJoin can be used to join build operation (not supported when compiled with some older TBB versions)
  RTC_CONFIG_COMMIT_THREAD = 24,             //!< checks if rtcCommitThread is available (not supported when compiled with some older TBB versions)
};

/*! \brief Configures some device parameters.*/
RTCORE_API void rtcDeviceSetParameter1i(RTCDevice device, const uniform RTCParameter parm, uniform size_t val); // FIXME: should be ssize_t

/*! \brief Reads some device parameters. */
RTCORE_API uniform size_t rtcDeviceGetParameter1i(RTCDevice device, const uniform RTCParameter parm); // FIXME: should return ssize_t

/*! \brief Error codes returned by the rtcGetError function. */
enum RTCError {
  RTC_NO_ERROR = 0,          //!< No error has been recorded.
  RTC_UNKNOWN_ERROR = 1,     //!< An unknown error has occured.
  RTC_INVALID_ARGUMENT = 2,  //!< An invalid argument is specified
  RTC_INVALID_OPERATION = 3, //!< The operation is not allowed for the specified object.
  RTC_OUT_OF_MEMORY = 4,     //!< There is not enough memory left to execute the command.
  RTC_UNSUPPORTED_CPU = 5,   //!< The CPU is not supported as it does not support SSE2.
  RTC_CANCELLED = 6          //!< The user has cancelled the operation through the RTCProgressMonitorFunc callback
};

/*! \brief Returns the value of the per-thread error flag. 

  If an error occurs this flag is set to an error code if it stores no
  previous error. The rtcGetError function reads and returns the
  currently stored error and clears the error flag again. */
RTCORE_API uniform RTCError rtcDeviceGetError(RTCDevice device);

/*! \brief Type of error callback function. */
typedef unmasked void (*uniform RTCErrorFunc)(void* uniform userPtr, const uniform RTCError code, const uniform int8* uniform str);

/*! \brief Sets a callback function that is called whenever an error occurs. */
RTCORE_API void rtcDeviceSetErrorFunction(RTCDevice device, uniform RTCErrorFunc func, void* uniform userPtr);

/*! \brief Type of memory consumption callback function. */
typedef uniform bool (*uniform RTCMemoryMonitorFunc)(const uniform uintptr_t bytes, const uniform bool post); // FIXME: should be ssize_t

/*! \brief Sets the memory consumption callback function which is
 *  called before or after the library allocates or frees memory. The
 *  userPtr pointer is passed to each invokation of the callback
 *  function. */
RTCORE_API void rtcDeviceSetMemoryMonitorFunction(RTCDevice device, RTCMemoryMonitorFunc func, void* uniform userPtr);

#include "rtcore_ray.isph"
#include "rtcore_scene.isph"
#include "rtcore_geometry.isph"
#include "rtcore_geometry_user.isph"

/*! \} */

#endif
