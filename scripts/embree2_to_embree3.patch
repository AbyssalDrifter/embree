
////////////////////////////////////////////////////////////////////////////////////////
// rtcore.h

@@{
embree2
=>
embree3
}@@

@@{
rtcNewDevice ()
=>
rtcNewDevice (NULL)
}@@

@@{
rtcDeleteDevice (EXPR e0)
=>
rtcReleaseDevice (e0)
}@@

@@{
rtcInit ()
=>
rtcInit (NULL)
}@@

@@{
rtcInit (EXPR e0);
=>
RTCDevice g_device = rtcInit (e0);
}@@

@@{
rtcExit ()
=>
rtcReleaseDevice (device)
}@@

@@{
rtcSetParameter1i (EXPR e0,EXPR e1)
=>
rtcSetDeviceProperty (g_device,e0,e1)
}@@

@@{
rtcGetParameter1i (EXPR e0)
=>
rtcGetDeviceProperty (g_device,e0)
}@@

@@{
rtcGetError ()
=>
rtcGetDeviceError (device)
}@@

@@{
RTC_ERROR_FUNCTION
=>
RTCErrorFunc
}@@

@@{
RTCErrorFunc2
=>
RTCErrorFunc
}@@

@@{
rtcSetErrorFunction(EXPR e0)
=>
rtcSetDeviceErrorFunction(g_device,e0,NULL)
}@@

@@{
rtcSetDeviceErrorFunction2(EXPR e0,EXPR e1,EXPR e2)
=>
rtcSetDeviceErrorFunction(e0,e1,e2)
}@@

@@{
RTC_MEMORY_MONITOR_FUNCTION
=>
RTCMemoryMonitorFunc
}@@

@@{
RTCMemoryMonitorFunc2
=>
RTCMemoryMonitorFunc
}@@

@@{
rtcSetMemoryMonitorFunction(EXPR e0)
=>
rtcSetDeviceMemoryMonitorFunction(g_device,e0,nullptr)
}@@

@@{
rtcSetDeviceMemoryMonitorFunction2(EXPR e0,EXPR e1,EXPR e2)
=>
rtcSetDeviceMemoryMonitorFunction(e0,e1,e2)
}@@

@@{
rtcDebug();
=>
}@@

////////////////////////////////////////////////////////////////////////////////////////
// rtcore_scene.h

@@{
RTC_SCENE_STATIC
=>
RTC_BUILD_QUALITY_MEDIUM
}@@

@@{
RTC_SCENE_DYNAMIC
=>
RTC_SCENE_FLAG_DYNAMIC
}@@

@@{
RTC_SCENE_COMPACT
=>
RTC_ACCEL_COMPACT
}@@

@@{
RTC_SCENE_COHERENT
=>
0
}@@

@@{
RTC_SCENE_INCOHERENT
=>
0
}@@

@@{
RTC_SCENE_HIGH_QUALITY
=>
RTC_BUILD_QUALITY_HIGH
}@@

@@{
RTC_SCENE_ROBUST
=>
RTC_ACCEL_ROBUST
}@@

@@{
RTCAlgorithmFlags ID id EXPR e0;
=>
@@{
ID id = EXPR e1;
=>
;
}@@
}@@

@@{
RTCAlgorithmFlags
=>
int
}@@

@@{
RTC_INTERSECT1
=>
0
}@@

@@{
RTC_INTERSECT4
=>
0
}@@

@@{
RTC_INTERSECT8
=>
0
}@@

@@{
RTC_INTERSECT16
=>
0
}@@

@@{
RTC_INTERPOLATE
=>
0
}@@

@@{
RTC_INTERSECT_STREAM
=>
0
}@@

@@{
RTCIntersectContext ID context;
=>
RTCIntersectContext context;
rtcInitIntersectContext(&context);
}@@

@@{
rtcNewScene(EXPR e0,EXPR e1)
=>
rtcNewScene(g_device,e0,e1)
}@@

@@{
ID scene = rtcNewScene(EXPR device,EXPR sflags,EXPR aflags);
=>
scene = rtcNewScene(device);
COMMENT rtcSetAccelFlags(scene,sflags); // FIXME: set proper accel flags
COMMENT rtcSetBuildQuality(scene,sflags); // FIXME: set proper build quality
COMMENT rtcSetSceneFlags(scene,sflags); // FIXME: set proper scene flags
}@@

@@{
return rtcDeviceNewScene(EXPR device,EXPR sflags,EXPR aflags);
=>
{
  RTCScene VAR scene = rtcNewScene(device);
  COMMENT rtcSetAccelFlags(scene,sflags); // FIXME: set proper accel flags
  COMMENT rtcSetBuildQuality(scene,sflags); // FIXME: set proper build quality
  COMMENT rtcSetSceneFlags(scene,sflags); // FIXME: set proper scene flags
  return scene;
}
}@@

@@{
rtcDeleteScene(EXPR scene)
=>
rtcReleaseScene(scene)
}@@

@@{
RTC_PROGRESS_MONITOR_FUNCTION
=>
RTCProgressMonitorFunc
}@@

@@{
rtcCommitThread(EXPR scene,EXPR threadID,EXPR numThreads)
=>
rtcCommitJoinScene(scene)
}@@

@@{
rtcGetBounds(EXPR scene,EXPR bounds)
=>
rtcGetSceneBounds(scene,&bounds)
}@@

@@{
rtcIntersect(EXPR scene, EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcIntersect1(scene,&context,&ray);
}
}@@

@@{
rtcIntersect1Ex(EXPR scene,EXPR context,EXPR ray);
=>
rtcIntersect1(scene,context,&ray);
}@@

@@{
rtcIntersect4(EXPR valid,EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcIntersect4(valid,scene,&context,&ray);
}
}@@

@@{
rtcIntersect4Ex(EXPR valid,EXPR scene,EXPR context,EXPR ray);
=>
rtcIntersect4(valid,scene,context,&ray);
}@@

@@{
rtcIntersect8(EXPR valid,EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcIntersect8(valid,scene,&context,&ray);
}
}@@

@@{
rtcIntersect8Ex(EXPR valid,EXPR scene,EXPR context,EXPR ray);
=>
rtcIntersect8(valid,scene,context,&ray);
}@@

@@{
rtcIntersect16(EXPR valid,EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcIntersect16(valid,scene,&context,&ray);
}
}@@

@@{
rtcIntersect16Ex(EXPR valid,EXPR scene,EXPR context,EXPR ray);
=>
rtcIntersect16(valid,scene,context,&ray);
}@@

@@{
rtcIntersectNp(EXPR scene,EXPR context,EXPR ray,EXPR N);
=>
rtcIntersectNp(scene,context,&ray,N);
}@@


@@{
rtcOccluded(EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcOccluded1(scene,&context,&ray);
}
}@@

@@{
rtcOccluded1Ex(EXPR scene,EXPR context,EXPR ray);
=>
rtcOccluded1(scene,context,&ray);
}@@

@@{
rtcOccluded4(EXPR valid,EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcOccluded4(valid,scene,&context,&ray);
}
}@@

@@{
rtcOccluded4Ex(EXPR valid,EXPR scene,EXPR context,EXPR ray);
=>
rtcOccluded4(valid,scene,context,&ray);
}@@

@@{
rtcOccluded8(EXPR valid,EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcOccluded8(valid,scene,&context,&ray);
}
}@@

@@{
rtcOccluded8Ex(EXPR valid,EXPR scene,EXPR context,EXPR ray);
=>
rtcOccluded8(valid,scene,context,&ray);
}@@

@@{
rtcOccluded16(EXPR valid,EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcOccluded16(valid,scene,&context,&ray);
}
}@@

@@{
rtcOccluded16Ex(EXPR valid,EXPR scene,EXPR context,EXPR ray);
=>
rtcOccluded16(valid,scene,context,&ray);
}@@

@@{
rtcOccludedNp(EXPR scene,EXPR context,EXPR ray,EXPR N);
=>
rtcOccludedNp(scene,context,&ray,N);
}@@


////////////////////////////////////////////////////////////////////////////////////////
// rtcore_geometry.h

@@{
RTCGeometryFlags
=>
RTCBuildQuality
}@@

@@{
RTC_GEOMETRY_STATIC
=>
RTC_BUILD_QUALITY_MEDIUM
}@@

@@{
RTC_GEOMETRY_DYNAMIC
=>
RTC_BUILD_QUALITY_LOW
}@@

@@{
RTC_GEOMETRY_DEFORMABLE
=>
RTC_BUILD_QUALITY_REFIT
}@@

@@{
RTC_BOUNDARY_NONE
=>
RTC_SUBDIVISION_MODE_NO_BOUNDARY
}@@

@@{
RTC_BOUNDARY_SMOOTH
=>
RTC_SUBDIVISION_MODE_SMOOTH_BOUNDARY
}@@

@@{
RTC_BOUNDARY_EDGE_ONLY
=>
RTC_SUBDIVISION_MODE_SMOOTH_BOUNDARY
}@@

@@{
RTC_BOUNDARY_EDGE_AND_CORNER
=>
RTC_SUBDIVISION_MODE_PIN_CORNERS
}@@

@@{
RTCBoundaryMode
=>
RTCSubdivisionMode
}@@

@@{
rtcSetBoundaryMode(EXPR scene,EXPR geomID,EXPR mode)
=>
rtcSetGeometrySubdivisionMode(scene,geomID,mode)
}@@


////////////////////////////////////////////////////////////////////////////////////////
// geometry modification functions

@@{
rtcSetTessellationRate(EXPR scene,EXPR geomID,EXPR rate)
=>
rtcSetGeometryTessellationRate(rtcGetGeometry(scene,geomID),rate)
}@@

@@{
rtcSetMask(EXPR scene,EXPR geomID,EXPR mask)
=>
rtcSetGeometryMask(rtcGetGeometry(scene,geomID),mask)
}@@

@@{
rtcSetSubdivisionMode(EXPR scene,EXPR geomID,EXPR topology,EXPR mode)
=>
rtcSetGeometrySubdivisionMode(rtcGetGeometry(scene,geomID),topology,mode)
}@@

@@{
rtcSetIndexBuffer(EXPR scene,EXPR geomID,EXPR buf0,EXPR buf1)
=>
rtcSetGeometryIndexBuffer(rtcGetGeometry(scene,geomID),buf0,buf1)
}@@

@@{
rtcMapBuffer(EXPR scene,EXPR geomID,EXPR type)
=>
rtcMapBuffer(rtcGetGeometry(scene,geomID),type)
}@@

@@{
rtcUnmapBuffer(EXPR scene,EXPR geomID,EXPR type)
=>
rtcUnmapBuffer(rtcGetGeometry(scene,geomID),type)
}@@

@@{
rtcSetBuffer(EXPR scene,EXPR geomID,EXPR type,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(rtcGetGeometry(scene,geomID),type,ptr,offset,stride)
}@@

@@{
rtcSetBuffer2(EXPR scene,EXPR geomID,EXPR type,EXPR ptr,EXPR offset,EXPR stride,EXPR size)
=>
rtcSetBuffer(rtcGetGeometry(scene,geomID),type,ptr,offset,stride,size)
}@@

@@{
rtcEnable(EXPR scene,EXPR geomID)
=>
rtcEnableGeometry(rtcGetGeometry(scene,geomID))
}@@

@@{
rtcDisable(EXPR scene,EXPR geomID)
=>
rtcDisableGeometry(rtcGetGeometry(scene,geomID))
}@@

@@{
rtcUpdate(EXPR scene,EXPR geomID)
=>
rtcCommitGeometry(rtcGetGeometry(scene,geomID))
}@@

@@{
rtcUpdateBuffer(EXPR scene,EXPR geomID,EXPR type)
=>
rtcUpdateBuffer(rtcGetGeometry(scene,geomID),type);
rtcCommitGeometry(rtcGetGeometry(scene,geomID)) /* FIXME: do commit once after all updates */
}@@

@@{
rtcSetDisplacementFunction(EXPR scene,EXPR geomID,EXPR func,EXPR bounds)
=>
rtcSetGeometryDisplacementFunction(rtcGetGeometry(scene,geomID),func,bounds)
}@@

@@{
rtcSetDisplacementFunction2(EXPR scene,EXPR geomID,EXPR func,EXPR bounds)
=>
rtcSetGeometryDisplacementFunction(rtcGetGeometry(scene,geomID),func,bounds)
}@@

@@{
rtcSetIntersectionFilterFunction(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectionFilterFunction4(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectionFilterFunction8(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectionFilterFunction16(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectionFilterFunctionN(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOcclusionFilterFunction(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOcclusionFilterFunction4(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOcclusionFilterFunction8(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOcclusionFilterFunction16(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccluddedFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOcclusionFilterFunctionN(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccluddedFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@


@@{
rtcSetUserData(EXPR scene,EXPR geomID,EXPR ptr)
=>
rtcSetGeometryUserData(rtcGetGeometry(scene,geomID),ptr)
}@@

@@{
rtcGetUserData(EXPR scene,EXPR geomID)
=>
rtcGetGeometryUserData(rtcGetGeometry(scene,geomID))
}@@


@@{
rtcInterpolate(EXPR scene,EXPR geomID,EXPR primID,EXPR u,EXPR v,EXPR buffer,EXPR P,EXPR dPdu,EXPR dPdv,EXPR numFloats)
=>
rtcInterpolate(rtcGetGeometry(scene,geomID),primID,u,v,buffer,P,dPdu,dPdv,NULL,NULL,NULL,numFloats)
}@@

@@{
rtcInterpolate2(EXPR scene,EXPR geomID,EXPR primID,EXPR u,EXPR v,EXPR buffer,EXPR P,EXPR dPdu,EXPR dPdv,EXPR ddPdudu,EXPR ddPdvdv,EXPR ddPdudv,EXPR numFloats)
=>
rtcInterpolate(rtcGetGeometry(scene,geomID),primID,u,v,buffer,P,dPdu,dPdv,ddPdudu,ddPdvdv,ddPdudv,numFloats)
}@@


@@{
rtcInterpolateN(EXPR scene,EXPR geomID,EXPR valid,EXPR primID,EXPR u,EXPR v,EXPR numUVs,EXPR buffer,EXPR P,EXPR dPdu,EXPR dPdv,EXPR numFloats)
=>
rtcInterpolateN(rtcGetGeometry(scene,geomID),valid,primID,u,v,numUVs,buffer,P,dPdu,dPdv,NULL,NULL,NULL,numFloats)
}@@

@@{
rtcInterpolateN2(EXPR scene,EXPR geomID,EXPR valid,EXPR primID,EXPR u,EXPR v,EXPR numUVs,EXPR buffer,EXPR P,EXPR dPdu,EXPR dPdv,EXPR ddPdudu,EXPR ddPdvdv,EXPR ddPdudv,EXPR numFloats)
=>
rtcInterpolateN(rtcGetGeometry(scene,geomID),valid,primID,u,v,numUVs,buffer,P,dPdu,dPdv,ddPdudu,ddPdvdv,ddPdudv,numFloats)
}@@



@@{
rtcSetBoundsFunction(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetBoundsFunctionX(rtcGetGeometry(scene,geomID),func,NULL)
}@@

@@{
rtcSetBoundsFunction2(EXPR scene,EXPR geomID,EXPR func,EXPR userPtr)
=>
rtcSetBoundsFunctionX(rtcGetGeometry(scene,geomID),func,userPtr)
}@@

@@{
rtcSetBoundsFunction3(EXPR scene,EXPR geomID,EXPR func,EXPR userPtr)
=>
rtcSetBoundsFunctionX(rtcGetGeometry(scene,geomID),func,userPtr)
}@@

@@{
rtcSetBoundsFunctionX(EXPR geom,EXPR func,EXPR userPtr)
=>
rtcSetGeometryBoundsFunction(geom,func,userPtr)
}@@


@@{
rtcSetIntersectFunction(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFunctionN(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectFunction4(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFunctionN(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectFunction8(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFunctionN(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectFunction16(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFunctionN(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectFunction1Mp(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFunctionN(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectFunctionN(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetIntersectFunctionN(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOccludedFunction(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFunctionN(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOccludedFunction4(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFunctionN(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOccludedFunction8(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFunctionN(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOccludedFunction16(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFunctionN(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOccludedFunction1Mp(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFunctionN(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOccludedFunctionN(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFunctionN(rtcGetGeometry(scene,geomID),func)
}@@





@@{
rtcDeleteGeometry(EXPR scene,EXPR geomID)
=>
rtcReleaseGeometry(rtcGetGeometry(scene,geomID))
}@@


//////////////////////////////////////////////////////////////////////////
// convert intersection filter functions

@@{
void EXPR intersectionFilter(void* ID geomUserPtr_in, RTCRay& ID ray_in)
{
=>
void intersectionFilter(const RTCFilterFunctionNArguments* args)
{
  int* valid = args->valid;
  void* geomUserPtr_in = args->geomUserPtr;
  COMMENT RTCIntersectContext* context = args->context;
  COMMENT RTCRay* ray_in = (RTCRay*) args->ray;
  RTCHit* potentialHit = (RTCHit*) args->potentialHit;
  unsigned int N = args->N;
  assert(N == 1);
  if (!valid[0]) return; // function may get called with zero mask
@@{
ray_in.
=>
potentialHit->
}@@
}@@

@@{
void EXPR intersectionFilterN(int* ID valid_in, void* ID geomUserPtr_in, const RTCIntersectContext* ID context_in, RTCRayN* ID ray_in, const RTCHitN* ID potentialHit_in, const size_t ID N_in)
{
=>
void intersectionFilterN(const RTCFilterFunctionNArguments* args)
{
  int* valid_in = args->valid;
  void* geomUserPtr_in = args->geomUserPtr;
  RTCIntersectContext* context_in = args->context;
  RTCRayN* ray_in = args->ray;
  RTCHitN* potentialHit_in = args->potentialHit;
  unsigned int N_in = args->N;
  // FIXME: function may get called with zero mask
}@@

///////////////////////////////////////////////////////////////////////
// convert user geometry callbacks

@@{
void EXPR instanceBoundsFunc(void* ID geomUserPtr_in, size_t ID item_in, RTCBounds& ID bounds_out)
{
=>
void instanceBoundsFunc(const RTCBoundsFunctionArguments* args)
{
  COMMENT void* userPtr = args->userPtr;
  void* geomUserPtr_in = args->geomUserPtr;
  size_t item_in = args->item;
  COMMENT unsigned int time = args->time;
  RTCBounds& bounds_out = *args->bounds_o;
}@@

@@{
void EXPR instanceBoundsFunc2(void* ID userPtr_in, void* ID geomUserPtr_in, size_t ID item_in, RTCBounds& ID bounds_out)
{
=>
void instanceBoundsFunc2(const RTCBoundsFunctionArguments* args)
{
  void* userPtr_in = args->userPtr;
  void* geomUserPtr_in = args->geomUserPtr;
  size_t item_in = args->item;
  COMMENT size_t time = args->time;
  RTCBounds& bounds_out = *args->bounds_o;
}@@

@@{
void EXPR instanceBoundsFunc3(void* ID userPtr_in, void* ID geomUserPtr_in, size_t ID item_in, size_t ID time_in, RTCBounds& ID bounds_out)
{
=>
void instanceBoundsFunc3(const RTCBoundsFunctionArguments* args)
{
  void* userPtr_in = args->userPtr;
  void* geomUserPtr_in = args->geomUserPtr;
  size_t item_in = args->item;
  size_t time_in = args->time;
  RTCBounds& bounds_out = *args->bounds_o;
}@@

@@{
void EXPR RTCIntersectFunc(void* ID geomUserPtr_in, RTCRay& ID ray_in, size_t ID item_in)
{
=>
void RTCIntersectFunc(const RTCIntersectFunctionNArguments* args)
{
  COMMENT void* valid_in = args->valid;
  void* geomUserPtr_in = args->geomUserPtr;
  COMMENT RTCIntersectContext* context_in = args->context;
  RTCRay& ray_in = *(RTCRay*) args->ray;
  unsigned int N_in = args->N;
  unsigned int item_in = args->item;
  assert(N_in == 1);
}@@

@@{
void EXPR RTCIntersectFunc4(const void* ID valid_in, void* ID geomUserPtr_in, RTCRay4& ID ray_in, size_t ID item_in)
{
=>
void RTCIntersectFunc4(const RTCIntersectFunctionNArguments* args)
{
  void* valid_in = args->valid;
  void* geomUserPtr_in = args->geomUserPtr;
  COMMENT RTCIntersectContext* context_in = args->context;
  RTCRay4& ray_in = *(RTCRay4*) args->ray;
  unsigned int N_in = args->N;
  unsigned int item_in = args->item;
  assert(N_in == 4);
}@@

@@{
void EXPR RTCIntersectFunc8(const void* ID valid_in, void* ID geomUserPtr_in, RTCRay8& ID ray_in, size_t ID item_in)
{
=>
void RTCIntersectFunc8(const RTCIntersectFunctionNArguments* args)
{
  void* valid_in = args->valid;
  void* geomUserPtr_in = args->geomUserPtr;
  COMMENT RTCIntersectContext* context_in = args->context;
  RTCRay8& ray_in = *(RTCRay8*) args->ray;
  unsigned int N_in = args->N;
  unsigned int item_in = args->item;
  assert(N_in == 8);
}@@

@@{
void EXPR RTCIntersectFunc16(const void* ID valid_in, void* ID geomUserPtr_in, RTCRay16& ID ray_in, size_t ID item_in)
{
=>
void RTCIntersectFunc16(const RTCIntersectFunctionNArguments* args)
{
  void* valid_in = args->valid;
  void* geomUserPtr_in = args->geomUserPtr;
  COMMENT RTCIntersectContext* context_in = args->context;
  RTCRay16& ray_in = *(RTCRay16*) args->ray;
  unsigned int N_in = args->N;
  unsigned int item_in = args->item;
  assert(N_in == 16);
}@@

@@{
void EXPR RTCIntersectFuncN(const int* ID valid_in, void* ID geomUserPtr_in, const RTCIntersectContext* ID context_in, RTCRayN* ID ray_in, size_t ID N_in, size_t ID item_in)
{
=>
void RTCIntersectFuncN(const RTCIntersectFunctionNArguments* args)
{
  const int* valid_in = args->valid;
  void* geomUserPtr_in = args->geomUserPtr;
  RTCIntersectContext* context_in = args->context;
  RTCRayN* ray_in = args->ray;
  unsigned int N_in = args->N;
  unsigned int item_in = args->item;
}@@


////////////////////////////////////////////////////////////////////////////////////////
// geometries

@@{
unsigned int ID geomID = REGEXPR(name,rtcNew.*)(
=>
unsigned int geomID;
geomID = name(
}@@

@@{
int ID geomID = REGEXPR(name,rtcNew.*)(
=>
int geomID;
geomID = name(
}@@


////////////////////////////////////////////////////////////////////////////////////////
// user geometry

@@{
rtcNewUserGeometry
=>
rtcNewUserGeometry2
}@@

@@{
rtcNewUserGeometry2 (EXPR scene, EXPR numPrimitives)
=>
rtcNewUserGeometry2 (scene, numPrimitives, 1)
}@@

@@{
rtcNewUserGeometry2 (EXPR scene, EXPR numPrimitives, EXPR numTimeSteps)
=>
rtcNewUserGeometry3 (scene, RTC_BUILD_QUALITY_MEDIUM, numPrimitives, numTimeSteps)
}@@

@@{
rtcNewUserGeometry3 (EXPR scene, EXPR quality, EXPR numPrimitives)
=>
rtcNewUserGeometry3 (scene, quality, numPrimitives, 1)
}@@

@@{
rtcNewUserGeometry3
=>
rtcNewUserGeometry4
}@@

@@{
rtcNewUserGeometry4 (EXPR scene, EXPR quality, EXPR numPrimitives)
=>
rtcNewUserGeometry4 (scene, quality, numPrimitives, 1)
}@@

@@{
ID geomID = rtcNewUserGeometry4 (EXPR scene, EXPR quality, EXPR numPrimitives, EXPR numTimeSteps)
=>
RTCGeometry VAR geom = rtcNewUserGeometry (g_device, quality, numPrimitives, numTimeSteps);
geomID = rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewUserGeometry4 (EXPR scene, EXPR quality, EXPR numPrimitives, EXPR numTimeSteps)
=>
RTCGeometry VAR geom = rtcNewUserGeometry (g_device, quality, numPrimitives, numTimeSteps);
rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewUserGeometry4 (EXPR scene, EXPR quality, EXPR numPrimitives, EXPR numTimeSteps, EXPR geomID)
=>
RTCGeometry VAR geom = rtcNewUserGeometry (g_device, quality, numPrimitives, numTimeSteps);
rtcAttachGeometryById(scene,geom,geomID);
rtcReleaseGeometry(geom);
}@@

@@{
RTCGeometry ID geom = rtcNewUserGeometry (EXPR device, EXPR quality, EXPR numPrimitives, EXPR numTimeSteps)
=>
RTCGeometry ID geom = rtcNewUserGeometry (EXPR device, EXPR quality, EXPR numPrimitives, EXPR numTimeSteps);
rtcSetGeometryBuildQuality(geom,quality);
rtcSetNumPrimitives(geom,numPrimitives);
rtcSetNumTimeSteps(geom,numTimeSteps);
}@@

@@{
rtcSetBoundsFunction (EXPR scene, EXPR geomID, EXPR func)
=>
rtcSetBoundsFunction (rtcGetGeometry(scene,geomID), func)
}@@

@@{
rtcSetBoundsFunction2 (EXPR scene, EXPR geomID, EXPR func, EXPR userPtr)
=>
rtcSetBoundsFunction (rtcGetGeometry(scene,geomID), func)
}@@

@@{
rtcSetBoundsFunction3 (EXPR scene, EXPR geomID, EXPR func, EXPR userPtr)
=>
rtcSetBoundsFunction (rtcGetGeometry(scene,geomID), func)
}@@

@@{
REGEXPR(name,rtcSetIntersectFunction.*)(
=>
rtcSetIntersectFunction(
}@@

@@{
rtcSetIntersectFunction (EXPR scene, EXPR geomID, EXPR func)
=>
rtcSetIntersectFunction (rtcGetGeometry(scene,geomID), func)
}@@

@@{
REGEXPR(name,rtcSetOccludedFunction.*)(
=>
rtcSetOccludedFunction(
}@@

@@{
rtcSetOccludedFunction (EXPR scene, EXPR geomID, EXPR func)
=>
rtcSetOccludedFunction (rtcGetGeometry(scene,geomID), func)
}@@


////////////////////////////////////////////////////////////////////////////////////////
// instance

@@{
rtcNewInstance
=>
rtcNewInstance2
}@@

@@{
rtcNewInstance2
=>
rtcNewInstance3
}@@

@@{
rtcNewInstance3(EXPR target,EXPR source)
=>
rtcNewInstance3(target,source,1)
}@@

@@{
ID geomID = rtcNewInstance3(EXPR target,EXPR source,EXPR numTimeSteps);
=>
RTCGeometry VAR geom = rtcNewInstance (g_device,source,numTimeSteps);
geomID = rtcAttachGeometry(target,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewInstance3(EXPR target,EXPR source,EXPR numTimeSteps);
=>
RTCGeometry VAR geom = rtcNewInstance (g_device,source,numTimeSteps);
rtcAttachGeometry(target,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewInstance3(EXPR target,EXPR source,EXPR numTimeSteps,EXPR geomID);
=>
RTCGeometry VAR geom = rtcNewInstance (g_device,source,numTimeSteps);
rtcAttachGeometryById(target,geom,geomID);
rtcReleaseGeometry(geom);
}@@

@@{
rtcSetTransform(EXPR scene,EXPR geomID,EXPR layout,EXPR xfm)
=>
rtcSetTransform2(scene,geomID,layout,xfm,0)
}@@

@@{
rtcSetTransform2(EXPR scene,EXPR geomID,EXPR layout,EXPR xfm,EXPR timeStep)
=>
rtcSetGeometryTransform(rtcGetGeometry(scene,geomID),layout,xfm,timeStep)
}@@


////////////////////////////
// rtcNewTriangleMesh

@@{
rtcNewTriangleMesh
=>
rtcNewTriangleMesh2
}@@

@@{
rtcNewTriangleMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewTriangleMesh2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
ID geomID = rtcNewTriangleMesh2 (EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
RTCGeometry VAR geom = rtcNewTriangleMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
geomID = rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewTriangleMesh2 (EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
RTCGeometry VAR geom = rtcNewTriangleMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewTriangleMesh2 (EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID);
=>
RTCGeometry VAR geom = rtcNewTriangleMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometryById(scene,geom,geomID);
rtcReleaseGeometry(geom);
}@@

////////////////////////////
// rtcNewQuadMesh

@@{
rtcNewQuadMesh
=>
rtcNewQuadMesh2
}@@

@@{
rtcNewQuadMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewQuadMesh2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
ID geomID = rtcNewQuadMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
RTCGeometry VAR geom = rtcNewQuadMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
geomID = rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewQuadMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
RTCGeometry VAR geom = rtcNewQuadMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewQuadMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID);
=>
RTCGeometry VAR geom = rtcNewQuadMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometryById(scene,geom,geomID);
rtcReleaseGeometry(geom);
}@@


////////////////////////////
// rtcNewSubdivisionMesh

@@{
rtcNewSubdivisionMesh
=>
rtcNewSubdivisionMesh2
}@@

@@{
rtcNewSubdivisionMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles)
=>
rtcNewSubdivisionMesh2(scene,flags,numPrimitives,numEdges,numVertices,numEdgeCreases,numVertexCreases,numHoles,1)
}@@

@@{
ID geomID = rtcNewSubdivisionMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles,EXPR numTimeSteps);
=>
RTCGeometry VAR geom = rtcNewSubdivisionMesh (g_device,flags,numPrimitives,numEdges,numVertices,numEdgeCreases,numVertexCreases,numHoles,numTimeSteps);
geomID = rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewSubdivisionMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles,EXPR numTimeSteps);
=>
RTCGeometry VAR geom = rtcNewSubdivisionMesh (g_device,flags,numPrimitives,numEdges,numVertices,numEdgeCreases,numVertexCreases,numHoles,numTimeSteps);
rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewSubdivisionMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles,EXPR numTimeSteps,EXPR geomID);
=>
RTCGeometry VAR geom = rtcNewSubdivisionMesh (g_device,flags,numPrimitives,numEdges,numVertices,numEdgeCreases,numVertexCreases,numHoles,numTimeSteps);
rtcAttachGeometryById(scene,geom,geomID);
rtcReleaseGeometry(geom);
}@@


////////////////////////////
// rtcNewCurveGeometry

@@{
rtcNewHairGeometry
=>
rtcNewBezierGeometry
}@@

@@{
rtcNewBezierHairGeometry
=>
rtcNewBezierHairGeometry2
}@@

@@{
rtcNewBezierHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewBezierHairGeometry2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
rtcNewBezierHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewCurveGeometryX(scene,RTC_CURVE_BASIS_BEZIER,RTC_INTERSECT_MODE_RIBBON,flags,numPrimitives,numVertices,numTimeSteps)
}@@

@@{
rtcNewBezierHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID)
=>
rtcNewCurveGeometryX(scene,RTC_CURVE_BASIS_BEZIER,RTC_INTERSECT_MODE_RIBBON,flags,numPrimitives,numVertices,numTimeSteps,geomID)
}@@

@@{
rtcNewBSplineHairGeometry
=>
rtcNewBSplineHairGeometry2
}@@

@@{
rtcNewBSplineHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewBSplineHairGeometry2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
rtcNewBSplineHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewCurveGeometryX(scene,RTC_CURVE_BASIS_BSPLINE,RTC_INTERSECT_MODE_RIBBON,flags,numPrimitives,numVertices,numTimeSteps)
}@@

@@{
rtcNewBSplineHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID)
=>
rtcNewCurveGeometryX(scene,RTC_CURVE_BASIS_BSPLINE,RTC_INTERSECT_MODE_RIBBON,flags,numPrimitives,numVertices,numTimeSteps,geomID)
}@@




@@{
rtcNewCurveGeometry
=>
rtcNewBezierCurveGeometry
}@@

@@{
rtcNewBezierCurveGeometry
=>
rtcNewBezierCurveGeometry2
}@@

@@{
rtcNewBezierCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewBezierCurveGeometry2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
rtcNewBezierCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewCurveGeometryX(scene,RTC_BASIS_BEZIER,RTC_GEOMETRY_INTERSECTOR_SURFACE,flags,numPrimitives,numVertices,numTimeSteps)
}@@

@@{
rtcNewBezierCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID)
=>
rtcNewCurveGeometryX(scene,RTC_CURVE_BASIS_BEZIER,RTC_INTERSECT_MODE_SURFACE,flags,numPrimitives,numVertices,numTimeSteps,geomID)
}@@

@@{
rtcNewBSplineCurveGeometry
=>
rtcNewBSplineCurveGeometry2
}@@

@@{
rtcNewBSplineCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewBSplineCurveGeometry2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
rtcNewBSplineCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewCurveGeometryX(scene,RTC_BASIS_BSPLINE,RTC_GEOMETRY_INTERSECTOR_SURFACE,flags,numPrimitives,numVertices,numTimeSteps)
}@@

@@{
rtcNewBSplineCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID)
=>
rtcNewCurveGeometryX(scene,RTC_CURVE_BASIS_BSPLINE,RTC_INTERSECT_MODE_SURFACE,flags,numPrimitives,numVertices,numTimeSteps,geomID)
}@@


@@{
rtcNewLineSegments
=>
rtcNewLineSegments2
}@@

@@{
rtcNewLineSegments2(EXPR scene,EXPR flags,EXPR numSegments,EXPR numVertices)
=>
rtcNewLineSegments2(scene,flags,numSegments,numVertices,1)
}@@

@@{
rtcNewLineSegments2(EXPR scene,EXPR flags,EXPR numSegments,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewCurveGeometryX (scene,RTC_BASIS_LINEAR,RTC_GEOMETRY_INTERSECTOR_RIBBON,flags,numSegments,numVertices,numTimeSteps)
}@@

@@{
rtcNewLineSegments2(EXPR scene,EXPR flags,EXPR numSegments,EXPR numVertices,EXPR numTimeSteps,EXPR geomID)
=>
rtcNewCurveGeometryX (scene,RTC_CURVE_BASIS_LINEAR,RTC_INTERSECT_MODE_RIBBON,flags,numSegments,numVertices,numTimeSteps,geomID)
}@@


@@{
ID geomID = rtcNewCurveGeometryX (EXPR scene,EXPR basis,EXPR intersector,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
RTCGeometry VAR geom = rtcNewCurveGeometry (g_device,basis,intersector,flags,numPrimitives,numVertices,numTimeSteps);
geomID = rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewCurveGeometryX (EXPR scene,EXPR basis,EXPR intersector,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
RTCGeometry VAR geom = rtcNewCurveGeometry (g_device,basis,intersector,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewCurveGeometryX (EXPR scene,EXPR basis,EXPR intersector,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID);
=>
RTCGeometry VAR geom = rtcNewCurveGeometry (g_device,basis,intersector,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometryById(scene,geom,geomID);
rtcReleaseGeometry(geom);
}@@


/////////////////////////////////
// optimize away rtcGetGeometry

@@{
ID geomID = rtcAttachGeometry(EXPR scene,EXPR geom);
=>
geomID = rtcAttachGeometry(scene,geom);
@@{
rtcGetGeometry (EXPR scene,EXPR geomID)
=>
geom
}@@
}@@

@@{
rtcAttachGeometryById(EXPR scene,EXPR geom,EXPR geomID);
=>
rtcAttachGeometryById(scene,geom,geomID);
@@{
rtcGetGeometry (EXPR scene,EXPR geomID)
=>
geom
}@@
}@@

////////////////////////////////////////////////////////////////////////////////////////
// add rtcCommitGeometry before every return

@@{
RTCGeometry ID geom = REGEXPR(name,rtcNew.*)(
=>
RTCGeometry geom = name(
@@{
return EXPR e0;
=>
rtcCommitGeometry(geom);
return e0;
}@@
}@@


/////////////////////////////////
// buffers

@@{
RTC_INDEX_BUFFER0
=>
RTC_INDEX_BUFFER
}@@

@@{
(RTCBufferType)(RTC_INDEX_BUFFER+EXPR t)
=>
RTC_INDEX_BUFFER_(t)
}@@

@@{
RTCBufferType(RTC_INDEX_BUFFER+EXPR t)
=>
RTC_INDEX_BUFFER_(t)
}@@

@@{
RTC_VERTEX_BUFFER0
=>
RTC_VERTEX_BUFFER
}@@

@@{
(RTCBufferType)(RTC_VERTEX_BUFFER+EXPR t)
=>
RTC_VERTEX_BUFFER_(t)
}@@

@@{
RTCBufferType(RTC_VERTEX_BUFFER+EXPR t)
=>
RTC_VERTEX_BUFFER_(t)
}@@

@@{
RTC_USER_VERTEX_BUFFER0
=>
RTC_USER_VERTEX_BUFFER
}@@

@@{
(RTCBufferType)(RTC_USER_VERTEX_BUFFER+EXPR t)
=>
RTC_USER_VERTEX_BUFFER_(t)
}@@

@@{
RTCBufferType(RTC_USER_VERTEX_BUFFER+EXPR t)
=>
RTC_USER_VERTEX_BUFFER_(t)
}@@

@@{
RTCGeometry ID geom = rtcNewTriangleMesh(EXPR device,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
RTCGeometry geom = rtcNewTriangleMesh(device,flags,numPrimitives,numVertices,numTimeSteps);
@@{
rtcMapBuffer(EXPR geom,RTC_INDEX_BUFFER)
=>
rtcNewBuffer(geom,RTC_INDEX_BUFFER,3*sizeof(int),numPrimitives)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_INDEX_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_INDEX_BUFFER,ptr,offset,stride,numPrimitives)
}@@
@@{
rtcMapBuffer(EXPR geom,REGEXPR(vertex_buffer,RTC_VERTEX_BUFFER.*))
=>
rtcNewBuffer(geom,vertex_buffer,4*sizeof(float),numVertices)
}@@
@@{
rtcSetBuffer(EXPR geom,REGEXPR(vertex_buffer,RTC_VERTEX_BUFFER.*),EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,vertex_buffer,ptr,offset,stride,numVertices)
}@@
@@{
rtcSetBuffer(EXPR geom,REGEXPR(user_vertex_buffer,RTC_USER_VERTEX_BUFFER.*),EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,user_vertex_buffer,ptr,offset,stride,numVertices)
}@@
}@@

@@{
RTCGeometry ID geom = rtcNewQuadMesh(EXPR device,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
RTCGeometry geom = rtcNewQuadMesh(device,flags,numPrimitives,numVertices,numTimeSteps);
@@{
rtcMapBuffer(EXPR geom,RTC_INDEX_BUFFER)
=>
rtcNewBuffer(geom,RTC_INDEX_BUFFER,4*sizeof(int),numPrimitives)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_INDEX_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_INDEX_BUFFER,ptr,offset,stride,numPrimitives)
}@@
@@{
rtcMapBuffer(EXPR geom,REGEXPR(vertex_buffer,RTC_VERTEX_BUFFER.*))
=>
rtcNewBuffer(geom,vertex_buffer,4*sizeof(float),numVertices)
}@@
@@{
rtcSetBuffer(EXPR geom,REGEXPR(vertex_buffer,RTC_VERTEX_BUFFER.*),EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,vertex_buffer,ptr,offset,stride,numVertices)
}@@
@@{
rtcSetBuffer(EXPR geom,REGEXPR(user_vertex_buffer,RTC_USER_VERTEX_BUFFER.*),EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,user_vertex_buffer,ptr,offset,stride,numVertices)
}@@
}@@

@@{
RTCGeometry ID geom = rtcNewSubdivisionMesh(EXPR device,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles,EXPR numTimeSteps);
=>
RTCGeometry geom = rtcNewSubdivisionMesh(device,flags,numPrimitives,numEdges,numVertices,numEdgeCreases,numVertexCreases,numHoles,numTimeSteps);
@@{
rtcMapBuffer(EXPR geom,RTC_FACE_BUFFER)
=>
rtcNewBuffer(geom,RTC_FACE_BUFFER,sizeof(int),numPrimitives)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_FACE_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_FACE_BUFFER,ptr,offset,stride,numPrimitives)
}@@
@@{
rtcMapBuffer(EXPR geom,RTC_INDEX_BUFFER)
=>
rtcNewBuffer(geom,RTC_INDEX_BUFFER,sizeof(int),numEdges)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_INDEX_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_INDEX_BUFFER,ptr,offset,stride,numEdges)
}@@
@@{
rtcMapBuffer(EXPR geom,REGEXPR(vertex_buffer,RTC_VERTEX_BUFFER.*))
=>
rtcNewBuffer(geom,vertex_buffer,4*sizeof(float),numVertices)
}@@
@@{
rtcSetBuffer(EXPR geom,REGEXPR(vertex_buffer,RTC_VERTEX_BUFFER.*),EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,vertex_buffer,ptr,offset,stride,numVertices)
}@@
@@{
rtcMapBuffer(EXPR geom,RTC_LEVEL_BUFFER)
=>
rtcNewBuffer(geom,RTC_LEVEL_BUFFER,sizeof(int),numEdges)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_LEVEL_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_LEVEL_BUFFER,ptr,offset,stride,numEdges)
}@@
@@{
rtcMapBuffer(EXPR geom,RTC_EDGE_CREASE_INDEX_BUFFER)
=>
rtcNewBuffer(geom,RTC_EDGE_CREASE_INDEX_BUFFER,2*sizeof(int),numEdgeCreases)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_EDGE_CREASE_INDEX_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_EDGE_CREASE_INDEX_BUFFER,ptr,offset,stride,numEdgeCreases)
}@@
@@{
rtcMapBuffer(EXPR geom,RTC_EDGE_CREASE_WEIGHT_BUFFER)
=>
rtcNewBuffer(geom,RTC_EDGE_CREASE_WEIGHT_BUFFER,sizeof(float),numEdgeCreases)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_EDGE_CREASE_WEIGHT_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_EDGE_CREASE_WEIGHT_BUFFER,ptr,offset,stride,numEdgeCreases)
}@@
@@{
rtcMapBuffer(EXPR geom,RTC_VERTEX_CREASE_INDEX_BUFFER)
=>
rtcNewBuffer(geom,RTC_VERTEX_CREASE_INDEX_BUFFER,sizeof(int),numVertexCreases)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_VERTEX_CREASE_INDEX_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_VERTEX_CREASE_INDEX_BUFFER,ptr,offset,stride,numVertexCreases)
}@@
@@{
rtcMapBuffer(EXPR geom,RTC_VERTEX_CREASE_WEIGHT_BUFFER)
=>
rtcNewBuffer(geom,RTC_VERTEX_CREASE_WEIGHT_BUFFER,sizeof(float),numVertexCreases)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_VERTEX_CREASE_WEIGHT_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_VERTEX_CREASE_WEIGHT_BUFFER,ptr,offset,stride,numVertexCreases)
}@@
@@{
rtcMapBuffer(EXPR geom,RTC_HOLE_BUFFER)
=>
rtcNewBuffer(geom,RTC_HOLE_BUFFER,sizeof(int),numPrimitives)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_HOLE_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_HOLE_BUFFER,ptr,offset,stride,numPrimitives)
}@@
@@{
rtcSetBuffer(EXPR geom,REGEXPR(user_vertex_buffer,RTC_USER_VERTEX_BUFFER.*),EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,user_vertex_buffer,ptr,offset,stride,numVertices) /* FIXME: verify size of this buffer! */
}@@
}@@

@@{
RTCGeometry ID geom = rtcNewCurveGeometry (EXPR device,EXPR basis,EXPR intersector,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
RTCGeometry geom = rtcNewCurveGeometry (device,basis,intersector,flags,numPrimitives,numVertices,numTimeSteps);
@@{
rtcMapBuffer(EXPR geom,RTC_INDEX_BUFFER)
=>
rtcNewBuffer(geom,RTC_INDEX_BUFFER,sizeof(int),numPrimitives)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_INDEX_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_INDEX_BUFFER,ptr,offset,stride,numPrimitives)
}@@
@@{
rtcMapBuffer(EXPR geom,REGEXPR(vertex_buffer,RTC_VERTEX_BUFFER.*))
=>
rtcNewBuffer(geom,vertex_buffer,4*sizeof(float),numVertices)
}@@
@@{
rtcSetBuffer(EXPR geom,REGEXPR(vertex_buffer,RTC_VERTEX_BUFFER.*),EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,vertex_buffer,ptr,offset,stride,numVertices)
}@@
@@{
rtcSetBuffer(EXPR geom,REGEXPR(user_vertex_buffer,RTC_USER_VERTEX_BUFFER.*),EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,user_vertex_buffer,ptr,offset,stride,numVertices)
}@@
}@@

@@{
rtcSetBuffer(EXPR geom,EXPR type,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,type,ptr,offset,stride,/* put buffer size here */)
}@@

@@{
rtcUnmapBuffer(EXPR geom, EXPR type);
=>
}@@

@@{
rtcMapBuffer(EXPR geom,EXPR type)
=>
rtcGetBuffer(geom,type) /* FIXME: check if this should be rtcNewBuffer */
}@@


////////////////////////////////////////////////
// drop extra arguments of geometry creation


@@{
rtcNewTriangleMesh (EXPR device,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewTriangleMesh (device)
}@@

@@{
rtcNewQuadMesh (EXPR device,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewQuadMesh (device)
}@@

@@{
rtcNewSubdivisionMesh (EXPR device,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles,EXPR numTimeSteps)
=>
rtcNewSubdivisionMesh (device)
}@@

@@{
rtcNewCurveGeometry (EXPR device,EXPR basis,EXPR intersector,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewCurveGeometry (device,basis)
}@@


////////////////////////////////////////////////
// BVH build API

@@{
RTC_BUILD_QUALITY_NORMAL
=>
RTC_BUILD_QUALITY_MEDIUM
}@@

@@{
rtcBuildBVH(EXPR bvh, EXPR settings, EXPR primitives, EXPR numPrimitives, EXPR createNode, EXPR setNodeChildren, EXPR setNodeBounds, EXPR createLeaf, EXPR splitPrimitive, EXPR buildProgress, EXPR userPtr);
=>
rtcBuildBVH(bvh, &settings, primitives, numPrimitives, createNode, setNodeChildren, setNodeBounds, createLeaf, splitPrimitive, buildProgress, userPtr);
}@@

@@{
void* EXPR RTCCreateNodeFunc (RTCThreadLocalAllocator ID allocator, size_t ID numChildren, void* ID userPtr)
=>
void* RTCCreateNodeFunc (RTCThreadLocalAllocator allocator, unsigned int numChildren, void* userPtr)
}@@

@@{
void EXPR RTCSetNodeChildrenFunc (void* ID nodePtr, void** ID children, size_t ID numChildren, void* ID userPtr)
=>
void RTCSetNodeChildrenFunc (void* nodePtr, void** children, unsigned int numChildren, void* userPtr)
}@@

@@{
void EXPR RTCSetNodeBoundsFunc (void* ID nodePtr, const RTCBounds** ID bounds, size_t ID numChildren, void* ID userPtr)
=>
void RTCSetNodeBoundsFunc (void* nodePtr, const RTCBounds** bounds, unsigned int numChildren, void* userPtr)
}@@

//@@{
//void* EXPR RTCCreateLeafFunc (RTCThreadLocalAllocator ID allocator, const RTCBuildPrimitive* ID prims, size_t ID numPrims, void* ID userPtr)
//=>
//void* RTCCreateLeafFunc (RTCThreadLocalAllocator allocator, const RTCBuildPrimitive* prims, size_t numPrims, void* userPtr)
//}@@

@@{
void EXPR RTCSplitPrimitiveFunc (const RTCBuildPrimitive& ID prim, unsigned ID dim, float ID pos, RTCBounds& ID lbounds, RTCBounds& ID rbounds, void* ID userPtr)
{
=>
void RTCSplitPrimitiveFunc (const RTCBuildPrimitive* _prim, unsigned int dim, float pos, RTCBounds* _lbounds, RTCBounds* _rbounds, void* userPtr)
{
  const RTCBuildPrimitive& prim = *_prim;
  RTCBounds& lbounds = *_lbounds;
  RTCBounds& rbounds = *_rbounds;
}@@

@@{
void EXPR RTCSplitPrimitiveFunc (const RTCBuildPrimitive& ID prim, unsigned int ID dim, float ID pos, RTCBounds& ID lbounds, RTCBounds& ID rbounds, void* ID userPtr)
{
=>
void RTCSplitPrimitiveFunc (const RTCBuildPrimitive* prim, unsigned int dim, float pos, RTCBounds* lbounds, RTCBounds* rbounds, void* userPtr)
{
  const RTCBuildPrimitive& prim = *_prim;
  RTCBounds& lbounds = *_lbounds;
  RTCBounds& rbounds = *_rbounds;
}@@

@@{
void EXPR RTCBuildProgressFunc (size_t ID dn, void* ID userPtr)
{
=>
bool RTCBuildProgressFunc (void* userPtr, double _dn)
{
size_t dn = _dn; // FIXME: multiply by number of primitives
return true; // FIXME: you have to return true from this function
}@@

@@{
rtcDeleteBVH(EXPR bvh)
=>
rtcReleaseBVH(bvh)
}@@

////////////////////////////////////////////////
// special rules for tutorials

@@{
RTCRay
=>
Ray
}@@

@@{
Ray ID myray
=>
Ray myray
@@{
ID myray.tnear
=>
myray.tnear()
}@@
@@{
ID myray.tfar
=>
myray.tfar()
}@@
@@{
&ID myray
=>
RTCRay_(myray)
}@@
}@@

@@{
Ray& ID myray =
=>
Ray& myray =
@@{
ID myray.tnear
=>
myray.tnear()
}@@
@@{
ID myray.tfar
=>
myray.tfar()
}@@
@@{
&ID myray
=>
RTCRay_(myray)
}@@
}@@

@@{
RTCIntersectContext
=>
IntersectContext
}@@

@@{
IntersectContext ID cont;
=>
IntersectContext cont;
@@{
ID cont.flags
=>
cont.context.flags
}@@
@@{
&ID cont
=>
&cont.context
}@@
}@@

@@{
LINEAR_BASIS
=>
RTC_BASIS_LINEAR
}@@

@@{
BEZIER_BASIS
=>
RTC_BASIS_BEZIER
}@@

@@{
BSPLINE_BASIS
=>
RTC_BASIS_BSPLINE
}@@
