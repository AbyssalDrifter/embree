////////////////////////////////////////////////////////////////////////////////////////
// rtcore.h

@@{
embree2
=>
embree3
}@@

////////////////////////////////////////////////////////////////////////////////////////
// rtcore_device.h

@@{
rtcNewDevice ()
=>
rtcNewDevice (NULL)
}@@

@@{
rtcDeleteDevice (EXPR e0)
=>
rtcReleaseDevice (e0)
}@@

@@{
rtcInit ()
=>
rtcInit (NULL)
}@@

@@{
rtcInit (EXPR e0);
=>
RTCDevice g_device = rtcInit (e0);
}@@

@@{
rtcExit ()
=>
rtcReleaseDevice (g_device)
}@@

@@{
RTC_SOFTWARE_CACHE_SIZE
=>
RTC_DEVICE_PROPERTY_SOFTWARE_CACHE_SIZE
}@@

@@{
RTC_CONFIG_INTERSECT1
=>
RTC_DEVICE_PROPERTY_INTERSECT1_SUPPORTED
}@@

@@{
RTC_CONFIG_INTERSECT4
=>
RTC_DEVICE_PROPERTY_INTERSECT4_SUPPORTED
}@@

@@{
RTC_CONFIG_INTERSECT8
=>
RTC_DEVICE_PROPERTY_INTERSECT8_SUPPORTED
}@@

@@{
RTC_CONFIG_INTERSECT16
=>
RTC_DEVICE_PROPERTY_INTERSECT16_SUPPORTED
}@@

@@{
RTC_CONFIG_INTERSECT_STREAM
=>
RTC_DEVICE_PROPERTY_INTERSECT_STREAM_SUPPORTED
}@@

@@{
RTC_CONFIG_RAY_MASK
=>
RTC_DEVICE_PROPERTY_RAY_MASK_SUPPORTED
}@@

@@{
RTC_CONFIG_BACKFACE_CULLING
=>
RTC_DEVICE_PROPERTY_BACKFACE_CULLING_ENABLED
}@@

@@{
RTC_CONFIG_INTERSECTION_FILTER
=>
RTC_DEVICE_PROPERTY_FILTER_FUNCTION_SUPPORTED
}@@

@@{
RTC_CONFIG_INTERSECTION_FILTER_RESTORE
=>
/*RTC_DEVICE_PROPERTY_INTERSECTION_FILTER_RESTORE*/
}@@

@@{
RTC_CONFIG_IGNORE_INVALID_RAYS
=>
RTC_DEVICE_PROPERTY_IGNORE_INVALID_RAYS_ENABLED
}@@

@@{
RTC_CONFIG_TASKING_SYSTEM
=>
RTC_DEVICE_PROPERTY_TASKING_SYSTEM
}@@

@@{
RTC_CONFIG_VERSION_MAJOR
=>
RTC_DEVICE_PROPERTY_VERSION_MAJOR
}@@

@@{
RTC_CONFIG_VERSION_MINOR
=>
RTC_DEVICE_PROPERTY_VERSION_MINOR
}@@

@@{
RTC_CONFIG_VERSION_PATCH
=>
RTC_DEVICE_PROPERTY_VERSION_PATCH
}@@

@@{
RTC_CONFIG_VERSION
=>
RTC_DEVICE_PROPERTY_VERSION
}@@

@@{
RTC_CONFIG_TRIANGLE_GEOMETRY
=>
RTC_DEVICE_PROPERTY_TRIANGLE_GEOMETRY_SUPPORTED
}@@

@@{
RTC_CONFIG_QUAD_GEOMETRY
=>
RTC_DEVICE_PROPERTY_QUAD_GEOMETRY_SUPPORTED
}@@

@@{
RTC_CONFIG_LINE_GEOMETRY
=>
RTC_DEVICE_PROPERTY_LINE_GEOMETRY_SUPPORTED
}@@

@@{
RTC_CONFIG_HAIR_GEOMETRY
=>
RTC_DEVICE_PROPERTY_HAIR_GEOMETRY_SUPPORTED
}@@

@@{
RTC_CONFIG_SUBDIV_GEOMETRY
=>
RTC_DEVICE_PROPERTY_SUBDIVISION_GEOMETRY_SUPPORTED
}@@

@@{
RTC_CONFIG_USER_GEOMETRY
=>
RTC_DEVICE_PROPERTY_USER_GEOMETRY_SUPPORTED
}@@

@@{
RTC_CONFIG_COMMIT_JOIN
=>
RTC_DEVICE_PROPERTY_COMMIT_JOIN_SUPPORTED
}@@

@@{
RTC_CONFIG_COMMIT_THREAD
=>
/*RTC_DEVICE_PROPERTY_COMMIT_THREAD_SUPPORTED*/
}@@

@@{
rtcSetParameter1i (EXPR parm,EXPR val)
=>
rtcSetDeviceProperty (g_device,parm,val)
}@@

@@{
rtcGetParameter1i (EXPR parm)
=>
rtcGetDeviceProperty (g_device,parm)
}@@

@@{
rtcDeviceSetParameter1i (EXPR device,EXPR parm,EXPR val)
=>
rtcSetDeviceProperty (device,parm,val)
}@@

@@{
rtcDeviceGetParameter1i (EXPR device,EXPR parm)
=>
rtcGetDeviceProperty (device,parm)
}@@

@@{
RTC_NO_ERROR
=>
RTC_ERROR_NONE
}@@

@@{
RTC_UNKNOWN_ERROR
=>
RTC_ERROR_UNKNOWN
}@@

@@{
RTC_INVALID_ARGUMENT
=>
RTC_ERROR_INVALID_ARGUMENT
}@@

@@{
RTC_INVALID_OPERATION
=>
RTC_ERROR_INVALID_OPERATION
}@@

@@{
RTC_OUT_OF_MEMORY
=>
RTC_ERROR_OUT_OF_MEMORY
}@@

@@{
RTC_UNSUPPORTED_CPU
=>
RTC_ERROR_UNSUPPORTED_CPU
}@@

@@{
RTC_CANCELLED
=>
RTC_ERROR_CANCELLED
}@@
  
@@{
rtcGetError ()
=>
rtcGetDeviceError (g_device)
}@@

@@{
rtcDeviceGetError (EXPR device)
=>
rtcGetDeviceError (device)
}@@

@@{
RTC_ERROR_FUNCTION
=>
RTCErrorFunction
}@@

@@{
RTCErrorFunc
=>
RTCErrorFunction
}@@

@@{
RTCErrorFunc2
=>
RTCErrorFunction
}@@

@@{
rtcSetErrorFunction(EXPR func)
=>
rtcSetDeviceErrorFunction(g_device,func,NULL)
}@@

@@{
rtcDeviceSetErrorFunction(EXPR device,EXPR func)
=>
rtcSetDeviceErrorFunction(device,func,NULL)
}@@

@@{
rtcDeviceSetErrorFunction2(EXPR device,EXPR func,EXPR userPtr)
=>
rtcSetDeviceErrorFunction(device,func,userPtr)
}@@

@@{
void EXPR RTCErrorFunc (const RTCError ID error, const char* ID str)
{
=>
void RTCErrorFunc (uniform void* uniform userPtr, const uniform RTCError ID error, const uniform char* uniform str)
{
}@@

@@{
void EXPR RTCErrorFunc (const RTCError ID error, const char* ID str)
{
=>
void RTCErrorFunc (uniform void* uniform userPtr, const uniform RTCError ID error, const uniform int8* uniform str)
{
}@@

@@{
RTC_MEMORY_MONITOR_FUNCTION
=>
RTCMemoryMonitorFunction
}@@

@@{
RTCMemoryMonitorFunc
=>
RTCMemoryMonitorFunction
}@@

@@{
RTCMemoryMonitorFunc2
=>
RTCMemoryMonitorFunction
}@@

@@{
rtcSetMemoryMonitorFunction(EXPR func)
=>
rtcSetDeviceMemoryMonitorFunction(g_device,func,NULL)
}@@

@@{
rtcDeviceSetMemoryMonitorFunction(EXPR device,EXPR func)
=>
rtcSetDeviceMemoryMonitorFunction(device,func,NULL)
}@@

@@{
rtcDeviceSetMemoryMonitorFunction2(EXPR device,EXPR func,EXPR userPtr)
=>
rtcSetDeviceMemoryMonitorFunction(device,func,userPtr)
}@@

@@{
void EXPR RTCMemoryMonitorFunc (const ssize_t ID bytes, const bool ID post)
{
=>
void RTCMemoryMonitorFunc (uniform void* uniform userPtr, const uniform ssize_t bytes, const uniform bool post)
{
}@@

@@{
rtcDebug();
=>
}@@

////////////////////////////////////////////////////////////////////////////////////////
// rtcore_scene.h

@@{
RTC_BUILD_QUALITY_NORMAL
=>
RTC_BUILD_QUALITY_MEDIUM
}@@

@@{
RTC_SCENE_STATIC
=>
RTC_BUILD_QUALITY_MEDIUM
}@@

@@{
RTC_SCENE_DYNAMIC
=>
RTC_SCENE_FLAG_DYNAMIC | RTC_BUILD_QUALITY_LOW
}@@

@@{
RTC_SCENE_COMPACT
=>
RTC_SCENE_FLAG_COMPACT
}@@

@@{
RTC_SCENE_COHERENT
=>
RTC_SCENE_FLAG_NONE
}@@

@@{
RTC_SCENE_INCOHERENT
=>
RTC_SCENE_FLAG_NONE
}@@

@@{
RTC_SCENE_HIGH_QUALITY
=>
RTC_BUILD_QUALITY_HIGH
}@@

@@{
RTC_SCENE_ROBUST
=>
RTC_SCENE_FLAG_ROBUST
}@@

@@{
RTCAlgorithmFlags ID id EXPR e0;
=>
@@{
ID id = EXPR e1;
=>
;
}@@
}@@

@@{
RTCAlgorithmFlags
=>
int
}@@

@@{
RTC_INTERSECT1
=>
0
}@@

@@{
RTC_INTERSECT4
=>
0
}@@

@@{
RTC_INTERSECT8
=>
0
}@@

@@{
RTC_INTERSECT16
=>
0
}@@

@@{
RTC_INTERPOLATE
=>
0
}@@

@@{
RTC_INTERSECT_STREAM
=>
0
}@@

@@{
RTCIntersectFlags
=>
RTCIntersectContextFlags
}@@

@@{
RTC_INTERSECT_COHERENT
=>
RTC_INTERSECT_CONTEXT_FLAG_COHERENT
}@@

@@{
RTC_INTERSECT_INCOHERENT
=>
RTC_INTERSECT_CONTEXT_FLAG_INCOHERENT
}@@

@@{
RTCIntersectContext ID context;
=>
RTCIntersectContext context;
rtcInitIntersectContext(&context);
}@@

@@{
rtcNewScene(EXPR sflags,EXPR aflags)
=>
rtcDeviceNewScene(g_device,sflags,aflags)
}@@

@@{
rtcDeviceNewScene(EXPR device,EXPR sflags,EXPR aflags)
=>
rtcDeviceNewScene(device,sflags,aflags)
}@@

@@{
ID scene = rtcDeviceNewScene(EXPR device,EXPR sflags,EXPR aflags);
=>
scene = rtcNewScene(device);
COMMENT rtcSetSceneFlags(scene,sflags); // FIXME: set proper scene flags
COMMENT rtcSetSceneBuildQuality(scene,sflags); // FIXME: set proper build quality
}@@

@@{
return rtcDeviceNewScene(EXPR device,EXPR sflags,EXPR aflags);
=>
{
  RTCScene VAR scene = rtcNewScene(device);
  COMMENT rtcSetSceneFlags(scene,sflags); // FIXME: set proper scene flags
  COMMENT rtcSetSceneBuildQuality(scene,sflags); // FIXME: set proper build quality
  return scene;
}
}@@

@@{
rtcDeleteScene(EXPR scene)
=>
rtcReleaseScene(scene)
}@@

@@{
RTC_PROGRESS_MONITOR_FUNCTION
=>
RTCProgressMonitorFunction
}@@

@@{
RTCProgressMonitorFunc
=>
RTCProgressMonitorFunction
}@@

@@{
rtcSetProgressMonitorFunction
=>
rtcSetSceneProgressMonitorFunction
}@@

@@{
rtcCommit(EXPR scene)
=>
rtcCommitScene(scene)
}@@

@@{
rtcCommitJoin(EXPR scene)
=>
rtcCommitJoinScene(scene)
}@@

@@{
rtcCommitThread(EXPR scene,EXPR threadID,EXPR numThreads)
=>
rtcCommitJoinScene(scene)
}@@

@@{
rtcGetBounds(EXPR scene,EXPR bounds)
=>
rtcGetSceneBounds(scene,&bounds)
}@@

@@{
rtcGetLinearBounds(EXPR scene,EXPR bounds)
=>
rtcGetSceneLinearBounds(scene,bounds)
}@@

@@{cpp
rtcIntersect(EXPR scene, EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcIntersect1(scene,&context,&ray);
}
}@@

@@{ispc
rtcIntersect(EXPR scene, EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcIntersect(scene,&context,&ray);
}
}@@

@@{cpp
rtcIntersect1Ex(EXPR scene,EXPR context,EXPR ray);
=>
rtcIntersect1(scene,context,&ray);
}@@

@@{ispc
rtcIntersectEx(EXPR scene,EXPR context,EXPR ray);
=>
rtcIntersect(scene,context,&ray);
}@@

@@{
rtcIntersect4(EXPR valid,EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcIntersect4(valid,scene,&context,&ray);
}
}@@

@@{
rtcIntersect4Ex(EXPR valid,EXPR scene,EXPR context,EXPR ray);
=>
rtcIntersect4(valid,scene,context,&ray);
}@@

@@{
rtcIntersect8(EXPR valid,EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcIntersect8(valid,scene,&context,&ray);
}
}@@

@@{
rtcIntersect8Ex(EXPR valid,EXPR scene,EXPR context,EXPR ray);
=>
rtcIntersect8(valid,scene,context,&ray);
}@@

@@{
rtcIntersect16(EXPR valid,EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcIntersect16(valid,scene,&context,&ray);
}
}@@

@@{
rtcIntersect16Ex(EXPR valid,EXPR scene,EXPR context,EXPR ray);
=>
rtcIntersect16(valid,scene,context,&ray);
}@@

@@{
rtcIntersectNp(EXPR scene,EXPR context,EXPR ray,EXPR N);
=>
rtcIntersectNp(scene,context,&ray,N);
}@@


@@{cpp
rtcOccluded(EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcOccluded1(scene,&context,&ray);
}
}@@

@@{ispc
rtcOccluded(EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcOccluded(scene,&context,&ray);
}
}@@

@@{cpp
rtcOccluded1Ex(EXPR scene,EXPR context,EXPR ray);
=>
rtcOccluded1(scene,context,&ray);
}@@

@@{ispc
rtcOccluded1Ex(EXPR scene,EXPR context,EXPR ray);
=>
rtcOccluded(scene,context,&ray);
}@@

@@{
rtcOccluded4(EXPR valid,EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcOccluded4(valid,scene,&context,&ray);
}
}@@

@@{
rtcOccluded4Ex(EXPR valid,EXPR scene,EXPR context,EXPR ray);
=>
rtcOccluded4(valid,scene,context,&ray);
}@@

@@{
rtcOccluded8(EXPR valid,EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcOccluded8(valid,scene,&context,&ray);
}
}@@

@@{
rtcOccluded8Ex(EXPR valid,EXPR scene,EXPR context,EXPR ray);
=>
rtcOccluded8(valid,scene,context,&ray);
}@@

@@{
rtcOccluded16(EXPR valid,EXPR scene,EXPR ray);
=>
{
  RTCIntersectContext context;
  rtcInitIntersectContext(&context);
  rtcOccluded16(valid,scene,&context,&ray);
}
}@@

@@{
rtcOccluded16Ex(EXPR valid,EXPR scene,EXPR context,EXPR ray);
=>
rtcOccluded16(valid,scene,context,&ray);
}@@

@@{
rtcOccludedNp(EXPR scene,EXPR context,EXPR ray,EXPR N);
=>
rtcOccludedNp(scene,context,&ray,N);
}@@


////////////////////////////////////////////////////////////////////////////////////////
// rtcore_geometry.h

@@{
RTCGeometryFlags
=>
RTCBuildQuality
}@@

@@{
RTC_GEOMETRY_STATIC
=>
RTC_BUILD_QUALITY_MEDIUM
}@@

@@{
RTC_GEOMETRY_DEFORMABLE
=>
RTC_BUILD_QUALITY_REFIT
}@@

@@{
RTC_GEOMETRY_DYNAMIC
=>
RTC_BUILD_QUALITY_LOW
}@@

@@{
RTC_BOUNDARY_NONE
=>
RTC_SUBDIVISION_MODE_NO_BOUNDARY
}@@

@@{
RTC_BOUNDARY_SMOOTH
=>
RTC_SUBDIVISION_MODE_SMOOTH_BOUNDARY
}@@

@@{
RTC_BOUNDARY_EDGE_ONLY
=>
RTC_SUBDIVISION_MODE_SMOOTH_BOUNDARY
}@@

@@{
RTC_BOUNDARY_EDGE_AND_CORNER
=>
RTC_SUBDIVISION_MODE_PIN_CORNERS
}@@

@@{
RTC_SUBDIV_NO_BOUNDARY
=>
RTC_SUBDIVISION_MODE_NO_BOUNDARY
}@@

@@{
RTC_SUBDIV_SMOOTH_BOUNDARY
=>
RTC_SUBDIVISION_MODE_SMOOTH_BOUNDARY
}@@

@@{
RTC_SUBDIV_PIN_CORNERS
=>
RTC_SUBDIVISION_MODE_PIN_CORNERS
}@@

@@{
RTC_SUBDIV_PIN_BOUNDARY
=>
RTC_SUBDIVISION_MODE_PIN_BOUNDARY
}@@

@@{
RTC_SUBDIV_PIN_ALL
=>
RTC_SUBDIVISION_MODE_PIN_ALL
}@@

@@{
RTCBoundaryMode
=>
RTCSubdivisionMode
}@@

///////////////////////////////////////////////////////////////////////
// convert filter function callbacks

@@{
RTCFilterFunc
=>
RTCFilterFunctionN
}@@

@@{
RTCFilterFunc4
=>
RTCFilterFunctionN
}@@

@@{
RTCFilterFunc8
=>
RTCFilterFunctionN
}@@

@@{
RTCFilterFunc16
=>
RTCFilterFunctionN
}@@

@@{
RTCFilterFuncN
=>
RTCFilterFunctionN
}@@

@@{
void EXPR intersectionFilter(void* ID geomUserPtr_in, RTCRay& ID ray_in)
{
=>
unmasked void intersectionFilter(const uniform RTCFilterFunctionNArguments* uniform const args)
{
  uniform int* uniform valid = args->valid;
  varying int* uniform vvalid = (varying int* uniform ) valid;
  void* uniform geomUserPtr_in = args->geomUserPtr;
  COMMENT uniform RTCIntersectContext* uniform context = args->context;
  COMMENT varying RTCRay* uniform ray_in = (varying RTCRay* uniform ) args->ray;
  varying RTCHit* uniform potentialHit = (varying RTCHit* uniform ) args->potentialHit;
  #warning use potentialHit to access hit
  uniform unsigned int N = args->N;
  assert(N == __programCount);
  if (*vvalid != -1) return;
@@{
ray_in.
=>
potentialHit->
}@@
}@@

@@{
void EXPR intersectionFilter4(const void* ID valid_in, void* ID geomUserPtr_in, RTCRay4& ID ray_in)
{
=>
void intersectionFilter4(const uniform RTCFilterFunctionNArguments* const uniform args)
{
  const void* valid_in = args->valid;
  void* geomUserPtr_in = args->geomUserPtr;
  COMMENT RTCIntersectContext* context = args->context;
  COMMENT RTCRay4* ray_in = (RTCRay4*) args->ray;
  RTCHit4* potentialHit = (RTCHit4*) args->potentialHit;
  #warning use potentialHit to access hit
  unsigned int N = args->N;
  assert(N == 4);
  if (none(valid)) return; // function may get called with zero mask
@@{
ray_in.
=>
potentialHit->
}@@
}@@

@@{
void EXPR intersectionFilter8(const void* ID valid_in, void* ID geomUserPtr_in, RTCRay8& ID ray_in)
{
=>
void intersectionFilter8(const uniform RTCFilterFunctionNArguments* const uniform args)
{
  const void* valid_in = args->valid;
  void* geomUserPtr_in = args->geomUserPtr;
  COMMENT RTCIntersectContext* context = args->context;
  COMMENT RTCRay8* ray_in = (RTCRay8*) args->ray;
  RTCHit8* potentialHit = (RTCHit8*) args->potentialHit;
  #warning use potentialHit to access hit
  unsigned int N = args->N;
  assert(N == 8);
  if (none(valid)) return; // function may get called with zero mask
@@{
ray_in.
=>
potentialHit->
}@@
}@@

@@{
void EXPR intersectionFilter16(const void* ID valid_in, void* ID geomUserPtr_in, RTCRay16& ID ray_in)
{
=>
void intersectionFilter16(const uniform RTCFilterFunctionNArguments* const uniform args)
{
  const void* valid_in = args->valid;
  void* geomUserPtr_in = args->geomUserPtr;
  COMMENT RTCIntersectContext* context = args->context;
  COMMENT RTCRay16* ray_in = (RTCRay16*) args->ray;
  RTCHit16* potentialHit = (RTCHit16*) args->potentialHit;
  #warning use potentialHit to access hit
  unsigned int N = args->N;
  assert(N == 16);
  if (none(valid)) return; // function may get called with zero mask
@@{
ray_in.
=>
potentialHit->
}@@
}@@

@@{
void EXPR intersectionFilterN(int* ID valid_in, void* ID geomUserPtr_in, const RTCIntersectContext* ID context_in, RTCRayN* ID ray_in, const RTCHitN* ID potentialHit_in, const size_t ID N_in)
{
=>
void intersectionFilterN(const uniform RTCFilterFunctionNArguments* const uniform args)
{
  int* uniform valid_in = args->valid;
  void* uniform geomUserPtr_in = args->geomUserPtr;
  RTCIntersectContext* uniform context_in = args->context;
  RTCRayN* uniform ray_in = args->ray;
  RTCHitN* uniform potentialHit_in = args->potentialHit;
  uniform unsigned int N_in = args->N;
  // FIXME: function may get called with zero mask
}@@


///////////////////////////////////////////////////////////////////////
// convert displacement function callbacks

@@{
RTCDisplacementFunc
=>
RTCDisplacementFunction
}@@

@@{
RTCDisplacementFunc2
=>
RTCDisplacementFunction
}@@

@@{
void EXPR RTCDisplacementFunc(void* ID geomUserPtr_in, unsigned int ID geomID_in, unsigned int ID primID_in,
const float* ID u_in, const float* ID v_in, const float* ID nx_in, const float* ID ny_in, const float* ID nz_in,
float* ID px_in, float* ID py_in, float* ID pz_in, size_t ID N_in)
{
=>
void RTCDisplacementFunc(const uniform RTCDisplacementFunctionArguments* const uniform args)
{
  void* uniform geomUserPtr_in = args->geomUserPtr;
  uniform unsigned int geomID_in = args->geomID;
  uniform unsigned int primID_in = args->primID;
  const float* uniform u_in = args->u;
  const float* uniform v_in = args->v;
  const float* uniform nx_in = args->nx;
  const float* uniform ny_in = args->ny;
  const float* uniform nz_in = args->nz;
  float* uniform px_in = args->px;
  float* uniform py_in = args->py;
  float* uniform pz_in = args->pz;
  size_t uniform N_in = args->N;
}@@

@@{
void EXPR RTCDisplacementFunc2(void* ID geomUserPtr_in, unsigned int ID geomID_in, unsigned int ID primID_in, unsigned int ID time_in,
const float* ID u_in, const float* ID v_in, const float* ID nx_in, const float* ID ny_in, const float* ID nz_in,
float* ID px_in, float* ID py_in, float* ID pz_in, size_t ID N_in)
{
=>
void RTCDisplacementFunc2(const uniform RTCDisplacementFunctionArguments* const uniform args)
{
  void* uniform geomUserPtr_in = args->geomUserPtr;
  uniform unsigned int geomID_in = args->geomID;
  uniform unsigned int primID_in = args->primID;
  uniform unsigned int time_in = args->time;
  const float* uniform u_in = args->u;
  const float* uniform v_in = args->v;
  const float* uniform nx_in = args->nx;
  const float* uniform ny_in = args->ny;
  const float* uniform nz_in = args->nz;
  float* uniform px_in = args->px;
  float* uniform py_in = args->py;
  float* uniform pz_in = args->pz;
  uniform size_t N_in = args->N;
}@@

///////////////////////////////////////////////////////////////////////
// convert user geometry callbacks

@@{
RTCBoundsFunc
=>
RTCBoundsFunction
}@@

@@{
void EXPR RTCBoundsFunc(void* ID geomUserPtr_in, size_t ID item_in, RTCBounds& ID bounds_out)
{
=>
void RTCBoundsFunc(const uniform RTCBoundsFunctionArguments* const uniform args)
{
  COMMENT void* uniform userPtr = args->userPtr;
  void* uniform geomUserPtr_in = args->geomUserPtr;
  uniform size_t item_in = args->item;
  COMMENT uniform unsigned int time = args->time;
  uniform RTCBounds& bounds_out = *args->bounds_o;
}@@

@@{
RTCBoundsFunc2
=>
RTCBoundsFunction
}@@

@@{
void EXPR RTCBoundsFunc2(void* ID userPtr_in, void* ID geomUserPtr_in, size_t ID item_in, RTCBounds& ID bounds_out)
{
=>
void RTCBoundsFunc2(const uniform RTCBoundsFunctionArguments* const uniform args)
{
  void* uniform userPtr_in = args->userPtr;
  void* uniform geomUserPtr_in = args->geomUserPtr;
  uniform size_t item_in = args->item;
  COMMENT uniform size_t time = args->time;
  uniform RTCBounds& bounds_out = *args->bounds_o;
}@@

@@{
RTCBoundsFunc3
=>
RTCBoundsFunction
}@@

@@{
void EXPR RTCBoundsFunc3(void* ID userPtr_in, void* ID geomUserPtr_in, size_t ID item_in, size_t ID time_in, RTCBounds& ID bounds_out)
{
=>
void RTCBoundsFunc3(const uniform RTCBoundsFunctionArguments* const uniform args)
{
  void* uniform userPtr_in = args->userPtr;
  void* uniform geomUserPtr_in = args->geomUserPtr;
  uniform size_t item_in = args->item;
  uniform size_t time_in = args->time;
  uniform RTCBounds& bounds_out = *args->bounds_o;
}@@

@@{
RTCIntersectFunc
=>
RTCIntersectFunctionN
}@@

@@{
RTCOccludedFunc
=>
RTCOccludedFunctionN
}@@

@@{
void EXPR RTCIntersectFunc(void* ID geomUserPtr_in, RTCRay& ID ray_in, size_t ID item_in)
{
=>
unmasked void RTCIntersectFunc(const uniform RTCIntersectFunctionNArguments* const uniform args) // FIXME: may also be RTCOccludedFunctionNArguments
{
  void* uniform valid_in = args->valid;
  varying int* uniform vvalid_in = (varying int* uniform ) valid_in;
  void* uniform geomUserPtr_in = args->geomUserPtr;
  COMMENT RTCIntersectContext* uniform context_in = args->context;
  varying RTCRay* uniform ray_ptr_in = (varying RTCRay* uniform ) args->ray;
  varying RTCRay& ray_in = *ray_ptr_in;
  uniform unsigned int N_in = args->N;
  uniform unsigned int item_in = args->item;
  assert(N_in == __programCount);
  if (*vvalid_in != -1) return;
}@@

@@{
RTCIntersectFunc4
=>
RTCIntersectFunctionN
}@@

@@{
RTCOccludedFunc4
=>
RTCOccludedFunctionN
}@@

@@{
void EXPR RTCIntersectFunc4(const void* ID valid_in, void* ID geomUserPtr_in, RTCRay4& ID ray_in, size_t ID item_in)
{
=>
void RTCIntersectFunc4(const uniform RTCIntersectFunctionNArguments* const uniform args) // FIXME: may also be RTCOccludedFunctionNArguments
{
  const void* valid_in = args->valid;
  void* geomUserPtr_in = args->geomUserPtr;
  COMMENT RTCIntersectContext* context_in = args->context;
  RTCRay4& ray_in = *(RTCRay4*) args->ray;
  unsigned int N_in = args->N;
  unsigned int item_in = args->item;
  assert(N_in == 4);
}@@

@@{
RTCIntersectFunc8
=>
RTCIntersectFunctionN
}@@

@@{
RTCOccludedFunc8
=>
RTCOccludedFunctionN
}@@

@@{
void EXPR RTCIntersectFunc8(const void* ID valid_in, void* ID geomUserPtr_in, RTCRay8& ID ray_in, size_t ID item_in)
{
=>
void RTCIntersectFunc8(const uniform RTCIntersectFunctionNArguments* const uniform args) // FIXME: may also be RTCOccludedFunctionNArguments
{
  const void* valid_in = args->valid;
  void* geomUserPtr_in = args->geomUserPtr;
  COMMENT RTCIntersectContext* context_in = args->context;
  RTCRay8& ray_in = *(RTCRay8*) args->ray;
  unsigned int N_in = args->N;
  unsigned int item_in = args->item;
  assert(N_in == 8);
}@@

@@{
RTCIntersectFunc16
=>
RTCIntersectFunctionN
}@@

@@{
RTCOccludedFunc16
=>
RTCOccludedFunctionN
}@@

@@{
void EXPR RTCIntersectFunc16(const void* ID valid_in, void* ID geomUserPtr_in, RTCRay16& ID ray_in, size_t ID item_in)
{
=>
void RTCIntersectFunc16(const uniform RTCIntersectFunctionNArguments* const uniform args) // FIXME: may also be RTCOccludedFunctionNArguments
{
  const void* valid_in = args->valid;
  void* geomUserPtr_in = args->geomUserPtr;
  COMMENT RTCIntersectContext* context_in = args->context;
  RTCRay16& ray_in = *(RTCRay16*) args->ray;
  unsigned int N_in = args->N;
  unsigned int item_in = args->item;
  assert(N_in == 16);
}@@

@@{
RTCIntersectFuncN
=>
RTCIntersectFunctionN
}@@

@@{
RTCOccludedFuncN
=>
RTCOccludedFunctionN
}@@

@@{
void EXPR RTCIntersectFuncN(const int* ID valid_in, void* ID geomUserPtr_in, const RTCIntersectContext* ID context_in, RTCRayN* ID ray_in, size_t ID N_in, size_t ID item_in)
{
=>
void RTCIntersectFuncN(const uniform RTCIntersectFunctionNArguments* const uniform args) // FIXME: may also be RTCOccludedFunctionNArguments
{
  const int* uniform valid_in = args->valid;
  void* uniform geomUserPtr_in = args->geomUserPtr;
  RTCIntersectContext* uniform context_in = args->context;
  RTCRayN* uniform ray_in = args->ray;
  uniform unsigned int N_in = args->N;
  uniform unsigned int item_in = args->item;
}@@

////////////////////////////////////////////////////////////////////////////////////////
// geometry modification functions

@@{
rtcSetTessellationRate(EXPR scene,EXPR geomID,EXPR rate)
=>
rtcSetGeometryTessellationRate(rtcGetGeometry(scene,geomID),rate)
}@@

@@{
rtcSetMask(EXPR scene,EXPR geomID,EXPR mask)
=>
rtcSetGeometryMask(rtcGetGeometry(scene,geomID),mask)
}@@

@@{
rtcSetBoundaryMode(EXPR scene,EXPR geomID,EXPR mode)
=>
rtcSetGeometrySubdivisionMode(rtcGetGeometry(scene,geomID),0,mode)
}@@

@@{
rtcSetSubdivisionMode(EXPR scene,EXPR geomID,EXPR topology,EXPR mode)
=>
rtcSetGeometrySubdivisionMode(rtcGetGeometry(scene,geomID),topology,mode)
}@@

@@{
rtcSetIndexBuffer(EXPR scene,EXPR geomID,EXPR buf0,EXPR buf1)
=>
rtcSetGeometryIndexBuffer(rtcGetGeometry(scene,geomID),buf0,buf1)
}@@

@@{
rtcMapBuffer(EXPR scene,EXPR geomID,EXPR type)
=>
rtcMapBuffer(rtcGetGeometry(scene,geomID),type)
}@@

@@{
rtcUnmapBuffer(EXPR scene,EXPR geomID,EXPR type)
=>
rtcUnmapBuffer(rtcGetGeometry(scene,geomID),type)
}@@

@@{
rtcSetBuffer(EXPR scene,EXPR geomID,EXPR type,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(rtcGetGeometry(scene,geomID),type,ptr,offset,stride)
}@@

@@{
rtcSetBuffer2(EXPR scene,EXPR geomID,EXPR type,EXPR ptr,EXPR offset,EXPR stride,EXPR size)
=>
rtcSetBuffer(rtcGetGeometry(scene,geomID),type,ptr,offset,stride,size)
}@@

@@{
rtcEnable(EXPR scene,EXPR geomID)
=>
rtcEnableGeometry(rtcGetGeometry(scene,geomID))
}@@

@@{
rtcDisable(EXPR scene,EXPR geomID)
=>
rtcDisableGeometry(rtcGetGeometry(scene,geomID))
}@@

@@{
rtcUpdate(EXPR scene,EXPR geomID)
=>
rtcCommitGeometry(rtcGetGeometry(scene,geomID))
}@@

@@{
rtcUpdateBuffer(EXPR scene,EXPR geomID,EXPR type)
=>
rtcUpdateBuffer(rtcGetGeometry(scene,geomID),type);
rtcCommitGeometry(rtcGetGeometry(scene,geomID)) /* FIXME: do commit once after all updates */
}@@

@@{
rtcSetDisplacementFunction(EXPR scene,EXPR geomID,EXPR func,EXPR bounds)
=>
rtcSetGeometryDisplacementFunction(rtcGetGeometry(scene,geomID),func,bounds)
}@@

@@{
rtcSetDisplacementFunction2(EXPR scene,EXPR geomID,EXPR func,EXPR bounds)
=>
rtcSetGeometryDisplacementFunction(rtcGetGeometry(scene,geomID),func,bounds)
}@@

@@{
rtcSetIntersectionFilterFunction(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectionFilterFunction4(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectionFilterFunction8(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectionFilterFunction16(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetIntersectionFilterFunctionN(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryIntersectFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOcclusionFilterFunction(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOcclusionFilterFunction4(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOcclusionFilterFunction8(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOcclusionFilterFunction16(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@

@@{
rtcSetOcclusionFilterFunctionN(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetGeometryOccludedFilterFunction(rtcGetGeometry(scene,geomID),func)
}@@


@@{
rtcSetUserData(EXPR scene,EXPR geomID,EXPR ptr)
=>
rtcSetGeometryUserData(rtcGetGeometry(scene,geomID),ptr)
}@@

@@{
rtcGetUserData(EXPR scene,EXPR geomID)
=>
rtcGetGeometryUserData(rtcGetGeometry(scene,geomID))
}@@


@@{
rtcInterpolate(EXPR scene,EXPR geomID,EXPR primID,EXPR u,EXPR v,EXPR buffer,EXPR P,EXPR dPdu,EXPR dPdv,EXPR numFloats)
=>
rtcInterpolate1(rtcGetGeometry(scene,geomID),primID,u,v,buffer,P,dPdu,dPdv,numFloats)
}@@

@@{
rtcInterpolate2(EXPR scene,EXPR geomID,EXPR primID,EXPR u,EXPR v,EXPR buffer,EXPR P,EXPR dPdu,EXPR dPdv,EXPR ddPdudu,EXPR ddPdvdv,EXPR ddPdudv,EXPR numFloats)
=>
rtcInterpolate2(rtcGetGeometry(scene,geomID),primID,u,v,buffer,P,dPdu,dPdv,ddPdudu,ddPdvdv,ddPdudv,numFloats)
}@@


@@{
rtcInterpolateN(EXPR scene,EXPR geomID,EXPR valid_in,EXPR primID_in,EXPR u_in,EXPR v_in,EXPR numUVs_in,EXPR buffer_in,EXPR P_o,EXPR dPdu_o,EXPR dPdv_o,EXPR numFloats_in)
=>
{
  RTCInterpolateNArguments args;
  args.geometry = rtcGetGeometry(scene,geomID);
  args.valid = valid_in;
  args.primIDs = primID_in;
  args.u = u_in;
  args.v = v_in;
  args.numUVs = numUVs_in;
  args.buffer = buffer_in;
  args.P = P_o;
  args.dPdu = dPdu_o;
  args.dPdv = dPdv_o;
  args.ddPdudu = NULL;
  args.ddPdvdv = NULL;
  args.ddPdudv = NULL;
  args.numFloats = numFloats_in;
  rtcInterpolateN(&args)
}
}@@

@@{
rtcInterpolateN2(EXPR scene,EXPR geomID,EXPR valid_in,EXPR primID_in,EXPR u_in,EXPR v_in,EXPR numUVs_in,EXPR buffer_in,EXPR P_o,EXPR dPdu_o,EXPR dPdv_o,EXPR ddPdudu_o,EXPR ddPdvdv_o,EXPR ddPdudv_o,EXPR numFloats_in)
=>
{
  RTCInterpolateNArguments args;
  args.geometry = rtcGetGeometry(scene,geomID);
  args.valid = valid_in;
  args.primIDs = primID_in;
  args.u = u_in;
  args.v = v_in;
  args.numUVs = numUVs_in;
  args.buffer = buffer_in;
  args.P = P_o;
  args.dPdu = dPdu_o;
  args.dPdv = dPdv_o;
  args.ddPdudu = ddPdudu_o;
  args.ddPdvdv = ddPdvdv_o;
  args.ddPdudv = ddPdudv_o;
  args.numFloats = numFloats_in;
  rtcInterpolateN(&args)
}
}@@



@@{
rtcSetBoundsFunction(EXPR scene,EXPR geomID,EXPR func)
=>
rtcSetBoundsFunctionX(rtcGetGeometry(scene,geomID),func,NULL)
}@@

@@{
rtcSetBoundsFunction2(EXPR scene,EXPR geomID,EXPR func,EXPR userPtr)
=>
rtcSetBoundsFunctionX(rtcGetGeometry(scene,geomID),func,userPtr)
}@@

@@{
rtcSetBoundsFunction3(EXPR scene,EXPR geomID,EXPR func,EXPR userPtr)
=>
rtcSetBoundsFunctionX(rtcGetGeometry(scene,geomID),func,userPtr)
}@@

@@{
rtcSetBoundsFunctionX(EXPR geom,EXPR func,EXPR userPtr)
=>
rtcSetGeometryBoundsFunction(geom,func,userPtr)
}@@

@@{
rtcSetIntersectFunction1Mp(EXPR scene,EXPR geomID,EXPR func);
=>
COMMENT rtcSetIntersectFunction1Mp(EXPR scene,EXPR geomID,EXPR func);
}@@

@@{
REGEXPR(name,rtcSetIntersectFunction.*)(
=>
rtcSetGeometryIntersectFunction(
}@@

@@{
rtcSetGeometryIntersectFunction (EXPR scene, EXPR geomID, EXPR func)
=>
rtcSetGeometryIntersectFunction (rtcGetGeometry(scene,geomID), func)
}@@

@@{
rtcSetOccludedFunction1Mp(EXPR scene,EXPR geomID,EXPR func);
=>
COMMENT rtcSetOccludedFunction1Mp(EXPR scene,EXPR geomID,EXPR func);
}@@

@@{
REGEXPR(name,rtcSetOccludedFunction.*)(
=>
rtcSetGeometryOccludedFunction(
}@@

@@{
rtcSetGeometryOccludedFunction (EXPR scene, EXPR geomID, EXPR func)
=>
rtcSetGeometryOccludedFunction (rtcGetGeometry(scene,geomID), func)
}@@

@@{
rtcDeleteGeometry(EXPR scene,EXPR geomID)
=>
rtcReleaseGeometry(rtcGetGeometry(scene,geomID))
}@@


////////////////////////////////////////////////////////////////////////////////////////
// geometries

@@{
unsigned int ID geomID = REGEXPR(name,rtcNew.*)(
=>
uniform unsigned int geomID;
geomID = name(
}@@

@@{
int ID geomID = REGEXPR(name,rtcNew.*)(
=>
uniform int geomID;
geomID = name(
}@@


////////////////////////////////////////////////////////////////////////////////////////
// user geometry

@@{
rtcNewUserGeometry
=>
rtcNewUserGeometry2
}@@

@@{
rtcNewUserGeometry2 (EXPR scene, EXPR numPrimitives)
=>
rtcNewUserGeometry2 (scene, numPrimitives, 1)
}@@

@@{
rtcNewUserGeometry2 (EXPR scene, EXPR numPrimitives, EXPR numTimeSteps)
=>
rtcNewUserGeometry3 (scene, RTC_BUILD_QUALITY_MEDIUM, numPrimitives, numTimeSteps)
}@@

@@{
rtcNewUserGeometry3 (EXPR scene, EXPR quality, EXPR numPrimitives)
=>
rtcNewUserGeometry3 (scene, quality, numPrimitives, 1)
}@@

@@{
rtcNewUserGeometry3
=>
rtcNewUserGeometry4
}@@

@@{
rtcNewUserGeometry4 (EXPR scene, EXPR quality, EXPR numPrimitives)
=>
rtcNewUserGeometry4 (scene, quality, numPrimitives, 1)
}@@

@@{
LHS geomID = rtcNewUserGeometry4 (EXPR scene, EXPR quality, EXPR numPrimitives, EXPR numTimeSteps)
=>
uniform RTCGeometry VAR geom = rtcNewUserGeometry (g_device, quality, numPrimitives, numTimeSteps);
geomID = rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewUserGeometry4 (EXPR scene, EXPR quality, EXPR numPrimitives, EXPR numTimeSteps)
=>
uniform RTCGeometry VAR geom = rtcNewUserGeometry (g_device, quality, numPrimitives, numTimeSteps);
rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewUserGeometry4 (EXPR scene, EXPR quality, EXPR numPrimitives, EXPR numTimeSteps, EXPR geomID)
=>
uniform RTCGeometry VAR geom = rtcNewUserGeometry (g_device, quality, numPrimitives, numTimeSteps);
rtcAttachGeometryById(scene,geom,geomID);
rtcReleaseGeometry(geom);
}@@

@@{
RTCGeometry ID geom = rtcNewUserGeometry (EXPR device, EXPR quality, EXPR numPrimitives, EXPR numTimeSteps)
=>
uniform RTCGeometry geom = rtcNewUserGeometry (device, quality, numPrimitives, numTimeSteps);
rtcSetGeometryBuildQuality(geom,quality);
rtcSetGeometryNumPrimitives(geom,numPrimitives);
rtcSetGeometryNumTimeSteps(geom,numTimeSteps);
}@@


////////////////////////////////////////////////////////////////////////////////////////
// instance

@@{
rtcNewInstance
=>
rtcNewInstance2
}@@

@@{
rtcNewInstance2
=>
rtcNewInstance3
}@@

@@{
rtcNewInstance3(EXPR target,EXPR source)
=>
rtcNewInstance3(target,source,1)
}@@

@@{
LHS geomID = rtcNewInstance3(EXPR target,EXPR source,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewInstance (g_device,source,numTimeSteps);
geomID = rtcAttachGeometry(target,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewInstance3(EXPR target,EXPR source,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewInstance (g_device,source,numTimeSteps);
rtcAttachGeometry(target,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewInstance3(EXPR target,EXPR source,EXPR numTimeSteps,EXPR geomID);
=>
uniform RTCGeometry VAR geom = rtcNewInstance (g_device,source,numTimeSteps);
rtcAttachGeometryById(target,geom,geomID);
rtcReleaseGeometry(geom);
}@@

@@{
rtcSetTransform
=>
rtcSetTransform2
}@@

@@{
rtcSetTransform2(EXPR scene,EXPR geomID,EXPR layout,EXPR xfm)
=>
rtcSetTransform2(scene,geomID,layout,xfm,0)
}@@

@@{
rtcSetTransform2(EXPR scene,EXPR geomID,EXPR layout,EXPR xfm,EXPR timeStep)
=>
rtcSetGeometryTransform(rtcGetGeometry(scene,geomID),layout,xfm,timeStep)
}@@


////////////////////////////
// rtcNewTriangleMesh

@@{
rtcNewTriangleMesh
=>
rtcNewTriangleMesh2
}@@

@@{
rtcNewTriangleMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewTriangleMesh2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
LHS geomID = rtcNewTriangleMesh2 (EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewTriangleMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
geomID = rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewTriangleMesh2 (EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewTriangleMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewTriangleMesh2 (EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID);
=>
uniform RTCGeometry VAR geom = rtcNewTriangleMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometryById(scene,geom,geomID);
rtcReleaseGeometry(geom);
}@@

////////////////////////////
// rtcNewQuadMesh

@@{
rtcNewQuadMesh
=>
rtcNewQuadMesh2
}@@

@@{
rtcNewQuadMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewQuadMesh2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
LHS geomID = rtcNewQuadMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewQuadMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
geomID = rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewQuadMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewQuadMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewQuadMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID);
=>
uniform RTCGeometry VAR geom = rtcNewQuadMesh (g_device,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometryById(scene,geom,geomID);
rtcReleaseGeometry(geom);
}@@


////////////////////////////
// rtcNewSubdivisionMesh

@@{
rtcNewSubdivisionMesh
=>
rtcNewSubdivisionMesh2
}@@

@@{
rtcNewSubdivisionMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles)
=>
rtcNewSubdivisionMesh2(scene,flags,numPrimitives,numEdges,numVertices,numEdgeCreases,numVertexCreases,numHoles,1)
}@@

@@{
LHS geomID = rtcNewSubdivisionMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewSubdivisionMesh (g_device,flags,numPrimitives,numEdges,numVertices,numEdgeCreases,numVertexCreases,numHoles,numTimeSteps);
geomID = rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewSubdivisionMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewSubdivisionMesh (g_device,flags,numPrimitives,numEdges,numVertices,numEdgeCreases,numVertexCreases,numHoles,numTimeSteps);
rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewSubdivisionMesh2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles,EXPR numTimeSteps,EXPR geomID);
=>
uniform RTCGeometry VAR geom = rtcNewSubdivisionMesh (g_device,flags,numPrimitives,numEdges,numVertices,numEdgeCreases,numVertexCreases,numHoles,numTimeSteps);
rtcAttachGeometryById(scene,geom,geomID);
rtcReleaseGeometry(geom);
}@@


////////////////////////////
// rtcNewCurveGeometry

@@{
rtcNewHairGeometry
=>
rtcNewBezierGeometry
}@@

@@{
rtcNewBezierHairGeometry
=>
rtcNewBezierHairGeometry2
}@@

@@{
rtcNewBezierHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewBezierHairGeometry2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
rtcNewBezierHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewCurveGeometryX(scene,RTC_GEOMETRY_TYPE_CURVE_BEZIER,RTC_GEOMETRY_SUBTYPE_RIBBON,flags,numPrimitives,numVertices,numTimeSteps)
}@@

@@{
rtcNewBezierHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID)
=>
rtcNewCurveGeometryX(scene,RTC_GEOMETRY_TYPE_CURVE_BEZIER,RTC_GEOMETRY_SUBTYPE_RIBBON,flags,numPrimitives,numVertices,numTimeSteps,geomID)
}@@

@@{
rtcNewBSplineHairGeometry
=>
rtcNewBSplineHairGeometry2
}@@

@@{
rtcNewBSplineHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewBSplineHairGeometry2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
rtcNewBSplineHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewCurveGeometryX(scene,RTC_GEOMETRY_TYPE_CURVE_BSPLINE,RTC_GEOMETRY_SUBTYPE_RIBBON,flags,numPrimitives,numVertices,numTimeSteps)
}@@

@@{
rtcNewBSplineHairGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID)
=>
rtcNewCurveGeometryX(scene,RTC_GEOMETRY_TYPE_CURVE_BSPLINE,RTC_GEOMETRY_SUBTYPE_RIBBON,flags,numPrimitives,numVertices,numTimeSteps,geomID)
}@@




@@{
rtcNewCurveGeometry
=>
rtcNewBezierCurveGeometry
}@@

@@{
rtcNewBezierCurveGeometry
=>
rtcNewBezierCurveGeometry2
}@@

@@{
rtcNewBezierCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewBezierCurveGeometry2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
rtcNewBezierCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewCurveGeometryX(scene,RTC_GEOMETRY_TYPE_CURVE_BEZIER,RTC_GEOMETRY_SUBTYPE_SURFACE,flags,numPrimitives,numVertices,numTimeSteps)
}@@

@@{
rtcNewBezierCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID)
=>
rtcNewCurveGeometryX(scene,RTC_GEOMETRY_TYPE_CURVE_BEZIER,RTC_GEOMETRY_SUBTYPE_SURFACE,flags,numPrimitives,numVertices,numTimeSteps,geomID)
}@@

@@{
rtcNewBSplineCurveGeometry
=>
rtcNewBSplineCurveGeometry2
}@@

@@{
rtcNewBSplineCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices)
=>
rtcNewBSplineCurveGeometry2(scene,flags,numPrimitives,numVertices,1)
}@@

@@{
rtcNewBSplineCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewCurveGeometryX(scene,RTC_GEOMETRY_TYPE_CURVE_BSPLINE,RTC_GEOMETRY_SUBTYPE_SURFACE,flags,numPrimitives,numVertices,numTimeSteps)
}@@

@@{
rtcNewBSplineCurveGeometry2(EXPR scene,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID)
=>
rtcNewCurveGeometryX(scene,RTC_GEOMETRY_TYPE_CURVE_BSPLINE,RTC_GEOMETRY_SUBTYPE_SURFACE,flags,numPrimitives,numVertices,numTimeSteps,geomID)
}@@


@@{
rtcNewLineSegments
=>
rtcNewLineSegments2
}@@

@@{
rtcNewLineSegments2(EXPR scene,EXPR flags,EXPR numSegments,EXPR numVertices)
=>
rtcNewLineSegments2(scene,flags,numSegments,numVertices,1)
}@@

@@{
rtcNewLineSegments2(EXPR scene,EXPR flags,EXPR numSegments,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewCurveGeometryX (scene,RTC_GEOMETRY_TYPE_CURVE_LINEAR,RTC_GEOMETRY_SUBTYPE_RIBBON,flags,numSegments,numVertices,numTimeSteps)
}@@

@@{
rtcNewLineSegments2(EXPR scene,EXPR flags,EXPR numSegments,EXPR numVertices,EXPR numTimeSteps,EXPR geomID)
=>
rtcNewCurveGeometryX (scene,RTC_GEOMETRY_TYPE_CURVE_LINEAR,RTC_GEOMETRY_SUBTYPE_RIBBON,flags,numSegments,numVertices,numTimeSteps,geomID)
}@@


@@{
LHS geomID = rtcNewCurveGeometryX (EXPR scene,EXPR basis,EXPR intersector,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewCurveGeometry (g_device,basis,intersector,flags,numPrimitives,numVertices,numTimeSteps);
geomID = rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewCurveGeometryX (EXPR scene,EXPR basis,EXPR intersector,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry VAR geom = rtcNewCurveGeometry (g_device,basis,intersector,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometry(scene,geom);
rtcReleaseGeometry(geom);
}@@

@@{
rtcNewCurveGeometryX (EXPR scene,EXPR basis,EXPR intersector,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps,EXPR geomID);
=>
uniform RTCGeometry VAR geom = rtcNewCurveGeometry (g_device,basis,intersector,flags,numPrimitives,numVertices,numTimeSteps);
rtcAttachGeometryById(scene,geom,geomID);
rtcReleaseGeometry(geom);
}@@


/////////////////////////////////
// optimize away rtcGetGeometry

@@{
LHS geomID = rtcAttachGeometry(EXPR scene,EXPR geom);
=>
geomID = rtcAttachGeometry(scene,geom);
@@{
rtcGetGeometry (EXPR scene,EXPR geomID)
=>
geom
}@@
}@@

@@{
rtcAttachGeometryById(EXPR scene,EXPR geom,EXPR geomID);
=>
rtcAttachGeometryById(scene,geom,geomID);
@@{
rtcGetGeometry (EXPR scene,EXPR geomID)
=>
geom
}@@
}@@

////////////////////////////////////////////////////////////////////////////////////////
// add rtcCommitGeometry before every return

@@{
RTCGeometry ID geom = REGEXPR(name,rtcNew.*)(
=>
uniform RTCGeometry geom = name(
@@{
return EXPR e0;
=>
rtcCommitGeometry(geom);
return e0;
}@@
}@@


/////////////////////////////////
// buffers

@@{
RTC_INDEX_BUFFER0
=>
RTC_INDEX_BUFFER
}@@

@@{
(RTCBufferType)(RTC_INDEX_BUFFER+EXPR t)
=>
RTC_INDEX_BUFFER_(t)
}@@

@@{
RTCBufferType(RTC_INDEX_BUFFER+EXPR t)
=>
RTC_INDEX_BUFFER_(t)
}@@

@@{
RTC_VERTEX_BUFFER0
=>
RTC_VERTEX_BUFFER
}@@

@@{
(RTCBufferType)(RTC_VERTEX_BUFFER+EXPR t)
=>
RTC_VERTEX_BUFFER_(t)
}@@

@@{
RTCBufferType(RTC_VERTEX_BUFFER+EXPR t)
=>
RTC_VERTEX_BUFFER_(t)
}@@

@@{
RTC_USER_VERTEX_BUFFER0
=>
RTC_USER_VERTEX_BUFFER
}@@

@@{
(RTCBufferType)(RTC_USER_VERTEX_BUFFER+EXPR t)
=>
RTC_USER_VERTEX_BUFFER_(t)
}@@

@@{
RTCBufferType(RTC_USER_VERTEX_BUFFER+EXPR t)
=>
RTC_USER_VERTEX_BUFFER_(t)
}@@

@@{
RTCGeometry ID geom = rtcNewTriangleMesh(EXPR device,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry geom = rtcNewTriangleMesh(device,flags,numPrimitives,numVertices,numTimeSteps);
@@{
rtcMapBuffer(EXPR geom,RTC_INDEX_BUFFER)
=>
rtcNewBuffer(geom,RTC_INDEX_BUFFER,3*sizeof(uniform int),numPrimitives)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_INDEX_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_INDEX_BUFFER,ptr,offset,stride,numPrimitives)
}@@
@@{
rtcMapBuffer(EXPR geom,REGEXPR(vertex_buffer,RTC_VERTEX_BUFFER.*))
=>
rtcNewBuffer(geom,vertex_buffer,4*sizeof(uniform float),numVertices)
}@@
@@{
rtcSetBuffer(EXPR geom,REGEXPR(vertex_buffer,RTC_VERTEX_BUFFER.*),EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,vertex_buffer,ptr,offset,stride,numVertices)
}@@
@@{
rtcSetBuffer(EXPR geom,REGEXPR(user_vertex_buffer,RTC_USER_VERTEX_BUFFER.*),EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,user_vertex_buffer,ptr,offset,stride,numVertices)
}@@
}@@

@@{
RTCGeometry ID geom = rtcNewQuadMesh(EXPR device,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry geom = rtcNewQuadMesh(device,flags,numPrimitives,numVertices,numTimeSteps);
@@{
rtcMapBuffer(EXPR geom,RTC_INDEX_BUFFER)
=>
rtcNewBuffer(geom,RTC_INDEX_BUFFER,4*sizeof(uniform int),numPrimitives)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_INDEX_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_INDEX_BUFFER,ptr,offset,stride,numPrimitives)
}@@
@@{
rtcMapBuffer(EXPR geom,REGEXPR(vertex_buffer,RTC_VERTEX_BUFFER.*))
=>
rtcNewBuffer(geom,vertex_buffer,4*sizeof(uniform float),numVertices)
}@@
@@{
rtcSetBuffer(EXPR geom,REGEXPR(vertex_buffer,RTC_VERTEX_BUFFER.*),EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,vertex_buffer,ptr,offset,stride,numVertices)
}@@
@@{
rtcSetBuffer(EXPR geom,REGEXPR(user_vertex_buffer,RTC_USER_VERTEX_BUFFER.*),EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,user_vertex_buffer,ptr,offset,stride,numVertices)
}@@
}@@

@@{
RTCGeometry ID geom = rtcNewSubdivisionMesh(EXPR device,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles,EXPR numTimeSteps);
=>
uniform RTCGeometry geom = rtcNewSubdivisionMesh(device,flags,numPrimitives,numEdges,numVertices,numEdgeCreases,numVertexCreases,numHoles,numTimeSteps);
@@{
rtcMapBuffer(EXPR geom,RTC_FACE_BUFFER)
=>
rtcNewBuffer(geom,RTC_FACE_BUFFER,sizeof(uniform int),numPrimitives)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_FACE_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_FACE_BUFFER,ptr,offset,stride,numPrimitives)
}@@
@@{
rtcMapBuffer(EXPR geom,RTC_INDEX_BUFFER)
=>
rtcNewBuffer(geom,RTC_INDEX_BUFFER,sizeof(uniform int),numEdges)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_INDEX_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_INDEX_BUFFER,ptr,offset,stride,numEdges)
}@@
@@{
rtcMapBuffer(EXPR geom,REGEXPR(vertex_buffer,RTC_VERTEX_BUFFER.*))
=>
rtcNewBuffer(geom,vertex_buffer,4*sizeof(uniform float),numVertices)
}@@
@@{
rtcSetBuffer(EXPR geom,REGEXPR(vertex_buffer,RTC_VERTEX_BUFFER.*),EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,vertex_buffer,ptr,offset,stride,numVertices)
}@@
@@{
rtcMapBuffer(EXPR geom,RTC_LEVEL_BUFFER)
=>
rtcNewBuffer(geom,RTC_LEVEL_BUFFER,sizeof(uniform int),numEdges)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_LEVEL_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_LEVEL_BUFFER,ptr,offset,stride,numEdges)
}@@
@@{
rtcMapBuffer(EXPR geom,RTC_EDGE_CREASE_INDEX_BUFFER)
=>
rtcNewBuffer(geom,RTC_EDGE_CREASE_INDEX_BUFFER,2*sizeof(uniform int),numEdgeCreases)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_EDGE_CREASE_INDEX_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_EDGE_CREASE_INDEX_BUFFER,ptr,offset,stride,numEdgeCreases)
}@@
@@{
rtcMapBuffer(EXPR geom,RTC_EDGE_CREASE_WEIGHT_BUFFER)
=>
rtcNewBuffer(geom,RTC_EDGE_CREASE_WEIGHT_BUFFER,sizeof(uniform float),numEdgeCreases)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_EDGE_CREASE_WEIGHT_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_EDGE_CREASE_WEIGHT_BUFFER,ptr,offset,stride,numEdgeCreases)
}@@
@@{
rtcMapBuffer(EXPR geom,RTC_VERTEX_CREASE_INDEX_BUFFER)
=>
rtcNewBuffer(geom,RTC_VERTEX_CREASE_INDEX_BUFFER,sizeof(uniform int),numVertexCreases)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_VERTEX_CREASE_INDEX_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_VERTEX_CREASE_INDEX_BUFFER,ptr,offset,stride,numVertexCreases)
}@@
@@{
rtcMapBuffer(EXPR geom,RTC_VERTEX_CREASE_WEIGHT_BUFFER)
=>
rtcNewBuffer(geom,RTC_VERTEX_CREASE_WEIGHT_BUFFER,sizeof(uniform float),numVertexCreases)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_VERTEX_CREASE_WEIGHT_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_VERTEX_CREASE_WEIGHT_BUFFER,ptr,offset,stride,numVertexCreases)
}@@
@@{
rtcMapBuffer(EXPR geom,RTC_HOLE_BUFFER)
=>
rtcNewBuffer(geom,RTC_HOLE_BUFFER,sizeof(uniform int),numPrimitives)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_HOLE_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_HOLE_BUFFER,ptr,offset,stride,numPrimitives)
}@@
@@{
rtcSetBuffer(EXPR geom,REGEXPR(user_vertex_buffer,RTC_USER_VERTEX_BUFFER.*),EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,user_vertex_buffer,ptr,offset,stride,numVertices) /* FIXME: verify size of this buffer! */
}@@
}@@

@@{
RTCGeometry ID geom = rtcNewCurveGeometry (EXPR device,EXPR basis,EXPR intersector,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps);
=>
uniform RTCGeometry geom = rtcNewCurveGeometry (device,basis,intersector,flags,numPrimitives,numVertices,numTimeSteps);
@@{
rtcMapBuffer(EXPR geom,RTC_INDEX_BUFFER)
=>
rtcNewBuffer(geom,RTC_INDEX_BUFFER,sizeof(uniform int),numPrimitives)
}@@
@@{
rtcSetBuffer(EXPR geom,RTC_INDEX_BUFFER,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,RTC_INDEX_BUFFER,ptr,offset,stride,numPrimitives)
}@@
@@{
rtcMapBuffer(EXPR geom,REGEXPR(vertex_buffer,RTC_VERTEX_BUFFER.*))
=>
rtcNewBuffer(geom,vertex_buffer,4*sizeof(uniform float),numVertices)
}@@
@@{
rtcSetBuffer(EXPR geom,REGEXPR(vertex_buffer,RTC_VERTEX_BUFFER.*),EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,vertex_buffer,ptr,offset,stride,numVertices)
}@@
@@{
rtcSetBuffer(EXPR geom,REGEXPR(user_vertex_buffer,RTC_USER_VERTEX_BUFFER.*),EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,user_vertex_buffer,ptr,offset,stride,numVertices)
}@@
}@@

@@{
rtcSetBuffer(EXPR geom,EXPR type,EXPR ptr,EXPR offset,EXPR stride)
=>
rtcSetBuffer(geom,type,ptr,offset,stride,/* put buffer size here */)
}@@

@@{
rtcUnmapBuffer(EXPR geom, EXPR type);
=>
}@@

@@{
rtcMapBuffer(EXPR geom,EXPR type)
=>
rtcGetBuffer(geom,type) /* FIXME: check if this should be rtcNewBuffer */
}@@

////////////////////////////////////////////////
// drop extra arguments of geometry creation

@@{
rtcNewUserGeometry (EXPR device, EXPR quality, EXPR numPrimitives, EXPR numTimeSteps)
=>
rtcNewGeometry (device, RTC_GEOMETRY_TYPE_USER)
}@@

@@{
rtcNewTriangleMesh (EXPR device,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewGeometry (device, RTC_GEOMETRY_TYPE_TRIANGLE)
}@@

@@{
rtcNewQuadMesh (EXPR device,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewGeometry (device, RTC_GEOMETRY_TYPE_QUAD)
}@@

@@{
rtcNewSubdivisionMesh (EXPR device,EXPR flags,EXPR numPrimitives,EXPR numEdges,EXPR numVertices,EXPR numEdgeCreases,EXPR numVertexCreases,EXPR numHoles,EXPR numTimeSteps)
=>
rtcNewGeometry (device, RTC_GEOMETRY_TYPE_SUBDIVISION)
}@@

@@{
rtcNewCurveGeometry (EXPR device,EXPR basis,EXPR intersector,EXPR flags,EXPR numPrimitives,EXPR numVertices,EXPR numTimeSteps)
=>
rtcNewGeometry (device,basis)
}@@


////////////////////////////////////////////////
// rtcore_builder.h

@@{
rtcBuildBVH(EXPR bvh, EXPR settings, EXPR primitives, EXPR numPrimitives, EXPR createNode, EXPR setNodeChildren, EXPR setNodeBounds, EXPR createLeaf, EXPR splitPrimitive, EXPR buildProgress, EXPR userPtr);
=>
rtcBuildBVH(bvh, &settings, primitives, numPrimitives, createNode, setNodeChildren, setNodeBounds, createLeaf, splitPrimitive, buildProgress, userPtr);
}@@

@@{
void* EXPR RTCCreateNodeFunc (RTCThreadLocalAllocator ID allocator, size_t ID numChildren, void* ID userPtr)
=>
void* RTCCreateNodeFunc (RTCThreadLocalAllocator allocator, unsigned int numChildren, void* userPtr)
}@@

@@{
void EXPR RTCSetNodeChildrenFunc (void* ID nodePtr, void** ID children, size_t ID numChildren, void* ID userPtr)
=>
void RTCSetNodeChildrenFunc (void* nodePtr, void** children, unsigned int numChildren, void* userPtr)
}@@

@@{
void EXPR RTCSetNodeBoundsFunc (void* ID nodePtr, const RTCBounds** ID bounds, size_t ID numChildren, void* ID userPtr)
=>
void RTCSetNodeBoundsFunc (void* nodePtr, const RTCBounds** bounds, unsigned int numChildren, void* userPtr)
}@@

//@@{
//void* EXPR RTCCreateLeafFunc (RTCThreadLocalAllocator ID allocator, const RTCBuildPrimitive* ID prims, size_t ID numPrims, void* ID userPtr)
//=>
//void* RTCCreateLeafFunc (RTCThreadLocalAllocator allocator, const RTCBuildPrimitive* prims, size_t numPrims, void* userPtr)
//}@@

@@{
void EXPR RTCSplitPrimitiveFunc (const RTCBuildPrimitive& ID prim, unsigned ID dim, float ID pos, RTCBounds& ID lbounds, RTCBounds& ID rbounds, void* ID userPtr)
{
=>
void RTCSplitPrimitiveFunc (const RTCBuildPrimitive* _prim, unsigned int dim, float pos, RTCBounds* _lbounds, RTCBounds* _rbounds, void* userPtr)
{
  const RTCBuildPrimitive& prim = *_prim;
  RTCBounds& lbounds = *_lbounds;
  RTCBounds& rbounds = *_rbounds;
}@@

@@{
void EXPR RTCSplitPrimitiveFunc (const RTCBuildPrimitive& ID prim, unsigned int ID dim, float ID pos, RTCBounds& ID lbounds, RTCBounds& ID rbounds, void* ID userPtr)
{
=>
void RTCSplitPrimitiveFunc (const RTCBuildPrimitive* prim, unsigned int dim, float pos, RTCBounds* lbounds, RTCBounds* rbounds, void* userPtr)
{
  const RTCBuildPrimitive& prim = *_prim;
  RTCBounds& lbounds = *_lbounds;
  RTCBounds& rbounds = *_rbounds;
}@@

@@{
void EXPR RTCBuildProgressFunc (size_t ID dn, void* ID userPtr)
{
=>
bool RTCBuildProgressFunc (void* uniform userPtr, uniform double _dn)
{
uniform size_t dn = _dn; // FIXME: multiply by number of primitives
return true; // FIXME: you have to return true from this function
}@@

@@{
rtcDeleteBVH(EXPR bvh)
=>
rtcReleaseBVH(bvh)
}@@

////////////////////////////////////////////////
// special rules for tutorials

@@{
RTCRay
=>
varying Ray
}@@

@@{
Ray ID myray
=>
varying Ray myray
@@{cpp
ID myray.tnear
=>
myray.tnear()
}@@
@@{cpp
ID myray.tfar
=>
myray.tfar()
}@@
@@{
&ID myray
=>
RTCRay_(myray)
}@@
}@@

@@{
Ray& ID myray =
=>
varying Ray& myray =
@@{cpp
ID myray.tnear
=>
myray.tnear()
}@@
@@{cpp
ID myray.tfar
=>
myray.tfar()
}@@
@@{
&ID myray
=>
RTCRay_(myray)
}@@
}@@

@@{
RTCIntersectContext* ID context_in = args->context;
=>
uniform IntersectContext* uniform context_in = (uniform IntersectContext* uniform ) args->context;
}@@

@@{
RTCIntersectContext
=>
IntersectContext
}@@

@@{
IntersectContext ID cont;
=>
uniform IntersectContext cont;
@@{
ID cont.flags
=>
cont.context.flags
}@@
@@{
&ID cont
=>
&cont.context
}@@
}@@

@@{
LINEAR_BASIS
=>
RTC_GEOMETRY_TYPE_CURVE_LINEAR
}@@

@@{
BEZIER_BASIS
=>
RTC_GEOMETRY_TYPE_CURVE_BEZIER
}@@

@@{
BSPLINE_BASIS
=>
RTC_GEOMETRY_TYPE_CURVE_BSPLINE
}@@


////////////////////////////////////////////////
// rtcore_ray.h

@@{
RTCRay ID ray;
=>
varying RTCRay ray;
@@{
ray.orgx
=>
ray.org_x
}@@
@@{
ray.orgy
=>
ray.org_y
}@@
@@{
ray.orgz
=>
ray.org_z
}@@
@@{
ray.dirx
=>
ray.dir_x
}@@
@@{
ray.diry
=>
ray.dir_y
}@@
@@{
ray.dirz
=>
ray.dir_z
}@@
@@{
ray.Ngx
=>
ray.Ng_x
}@@
@@{
ray.Ngy
=>
ray.Ng_y
}@@
@@{
ray.Ngz
=>
ray.Ng_z
}@@
}@@

@@{cpp
__programCount
=>
1
}@@

@@{ispc
__programCount
=>
programCount
}@@


