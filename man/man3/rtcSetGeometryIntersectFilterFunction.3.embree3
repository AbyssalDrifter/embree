.TH "rtcSetGeometryIntersectFilterFunction" "3" "" "" "Embree Ray Tracing Kernels 3"
.SS NAME
.IP
.nf
\f[C]
rtcSetGeometryIntersectFilterFunction\ \-\ sets\ intersection\ filter\ for\ geometry
\f[]
.fi
.SS SYNOPSIS
.IP
.nf
\f[C]
#include\ <embree3/rtcore.h>

struct\ RTCFilterFunctionNArguments
{
\ \ int*\ valid;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ //!<\ pointer\ to\ valid\ mask
\ \ void*\ geomUserPtr;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ //!<\ pointer\ to\ geometry\ user\ data
\ \ const\ struct\ RTCIntersectContext*\ context;\ //!<\ intersection\ context\ as\ passed\ to\ rtcIntersect/rtcOccluded
\ \ struct\ RTCRayN*\ ray;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ //!<\ ray\ and\ previous\ hit
\ \ struct\ RTCHitN*\ potentialHit;\ \ \ \ \ \ \ \ \ \ \ \ \ \ //!<\ potential\ new\ hit
\ \ unsigned\ int\ N;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ //!<\ size\ of\ ray\ packet
};

typedef\ void\ (*RTCFilterFunctionN)(const\ struct\ RTCFilterFunctionNArguments*\ const\ args);

void\ rtcSetGeometryIntersectFilterFunction(RTCGeometry\ geometry,\ RTCFilterFunctionN\ func);
\f[]
.fi
.SS DESCRIPTION
.PP
The \f[C]rtcSetGeometryIntersectFilterFunction\f[] function registers an
intersection filter callback function (\f[C]func\f[] argument) for the
specified geometry (\f[C]geometry\f[] argument).
Only a single callback function can get registered per geometry and
further invokations overwrite the previously set callback function.
Passing \f[C]NULL\f[] as function pointer disables the set callback
function again.
.PP
The registered intersection filter function is invoked for every hit
encountered during the \f[C]rtcIntersect\f[]\-type ray queries and can
accept or reject that hit.
The feature can be used to define a silhouette for a primitive and
reject hits that are outside the silhouette.
E.g.
a tree leaf could be modeled with an alpha texture that decides if hit
points lie inside or outside the leaf.
.PP
If the \f[C]RTC_SCENE_HIGH_QUALITY\f[] mode is set, the filter functions
may get called multiple times for the same hit.
Further, rays hitting the edge exactly might also report two hits for
the same surface.
For some usage cases, the application may have to work around this
limitation by collecting already reported hits (geomID/primID pairs) and
ignoring duplicates.
.PP
The filter function callback get passed a number of arguments through
the \f[C]RTCFilterFunctionNArguments\f[] structure.
The \f[C]valid\f[] parameter of that structure points to an integer
valid mask (0 means invalid and \-1 means valid).
The \f[C]geomUserPtr\f[] member is a user pointer optionally set per
geometry through the \f[C]rtcSetGeometryUserData\f[] function.
The \f[C]context\f[] parameter points to the intersection context passed
to the ray query function.
The \f[C]ray\f[] parameter contains a number of rays in SOA layout.
All hit data inside the \f[C]ray\f[] are undefined, except the
\f[C]tfar\f[] value.
The \f[C]potentialHit\f[] parameter points to a number of new hits in
SOA layout to test.
The \f[C]N\f[] parameter is the number of rays and hits found in the
\f[C]ray\f[] and \f[C]potentialHit\f[].
If the hit geometry is instanced, the \f[C]instID\f[] member of the ray
is valid and the ray as well as the potential hit are in object space.
.PP
The filter callback function has the task to check for each valid ray
whether it wants to accept or reject the corresponding hit.
To reject a hit, the filter callback function just has to write
\f[C]0\f[] to the integer valid mask of the corresponding ray, to accept
the hit it just has to leave the valid mask set to \f[C]\-1\f[].
The filter function is further allowed to change the potential hit and
decrease the \f[C]tfar\f[] value of the ray but it should not modify
further ray data nor any inactive components of ray nor potential hit.
.PP
When performing ray queries using the \f[C]rtcIntersect1/4/8/16\f[]
functions, it is guaranteed that the ray packet size \f[C]N\f[] (and the
order of rays inside the packet) passed to the the filter function
callback matches the initial ray packet size (and order).
When performing ray queries using the ray stream API (such as
\f[C]rtcIntersect1M\f[], \f[C]rtcIntersect1Mp\f[],
\f[C]rtcIntersectNM\f[], or \f[C]rtcIntersectNp\f[]) the order of rays
might change and the ray packet size of the callback function can be 1,
4, 8 or 16.
Use the \f[C]rayID\f[] component of the ray in case you need to identify
the original ray, e.g.
to access a per ray payload.
.PP
The implementation of the filter function can choose to implement a
single code path that uses the ray access helper functions
\f[C]RTCRay_XXX\f[] and hit access helper functions \f[C]RTCHit_XXX\f[]
to access ray and hit data.
Alternatively the code can branch to optimized implementations for
specific sizes of \f[C]N\f[] and cast the \f[C]ray\f[] and
\f[C]potentialHit\f[] input to the proper packet type.
.PP
The intersection filter callback of most applications will just copy the
\f[C]potentialHit\f[] into the appropiate fields of the ray, but this is
not a requirement and the hit data of the ray can get modified
arbitrarily.
Updating the \f[C]tfar\f[] distance to a smaller value (e.g.
the \f[C]t\f[] distance of the potential hit) is possible without
limitation.
However, increasing the \f[C]tfar\f[] distance of the ray to a larger
value \f[C]tfar\[aq]\f[] , does not guarantee intersections between
\f[C]tfar\f[] and \f[C]tfar\[aq]\f[] to be reported later, as the
corresponding subtrees might have gotten culled already.
.SS EXIT STATUS
.PP
On failure an error code is set that can get queried using
\f[C]rtcDeviceGetError\f[].
.SS SEE ALSO
.PP
[rtcSetGeometryOccludedFilterFunction]
