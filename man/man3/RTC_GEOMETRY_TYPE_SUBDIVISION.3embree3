.TH "RTC_GEOMETRY_TYPE_SUBDIVISION" "3" "" "" "Embree Ray Tracing Kernels 3"
.SS NAME
.IP
.nf
\f[C]
RTC_GEOMETRY_TYPE_SUBDIVISION\ \-\ subdivision\ geometry\ type
\f[]
.fi
.SS SYNOPSIS
.IP
.nf
\f[C]
#include\ <embree3/rtcore.h>

RTCGeometry\ geometry\ =\ rtcNewGeometry(device,\ RTC_GEOMETRY_TYPE_SUBDIVISION);
\f[]
.fi
.SS DESCRIPTION
.PP
Catmull\-Clark subdivision meshes are supported, including support for
edge creases, vertex creases, holes, non\-manifold geometry, and
face\-varying interpolation.
The number of vertices per face can be in the range of 3 to 15 vertices
(triangles, quadrilateral, pentagons, etc).
.PP
Subdivision meshes are created by passing
\f[C]RTC_GEOMETRY_TYPE_SUBDIVISION\f[] to the \f[C]rtcNewGeometry\f[]
function call.
Various buffers have to get set by the application to setup the
subdivision mesh.
The face buffer (\f[C]RTC_FACE_BUFFER\f[]) contains the number of
edges/indices of each face (3 to 15) and the number of faces is infered
from the size of this buffer.
The index buffer (\f[C]RTC_INDEX_BUFFER\f[]) contains multiple (3 to 15)
32\-bit vertex indices for each face and the number of edges is infered
from the size of this buffer.
The vertex buffer (\f[C]RTC_VERTEX_BUFFER\f[]) stores an array of single
precision \f[C]x\f[], \f[C]y\f[], \f[C]z\f[] floating point coordinates
and the number of vertices is infered from the size of this buffer.
.PP
Optionally the application may fill additional index buffers if multiple
topologies are required for face\-varying interpolation.
The standard vertex buffers \f[C]RTC_VERTEX_BUFFER\f[] are always bound
to the geometry topology (topology 0) thus use
\f[C]RTC_INDEX_BUFFER_(0)\f[].
User vertex data interpolation may use different topologies as described
later.
.PP
Optionally, the application can setup the hole buffer
(\f[C]RTC_HOLE_BUFFER\f[]) which contains an array of 32\-bit indices of
faces that should be considered non\-existing in all topologies.
The number of holes is infered from the size of this buffer.
.PP
Optionally, the application can fill the level buffer
(\f[C]RTC_LEVEL_BUFFER\f[]) with a tessellation rate for each of the
edges of each face.
This buffer must have the same size as the index buffer.
The tessellation level is a positive floating point value, that
specifies how many quads along the edge should get generated during
tessellation.
If no level buffer is specified a level of 1 is used.
The maximally supported edge level is 4096 and larger levels get clamped
to that value.
Note that some edges may be shared between (typically 2) faces.
To guarantee a watertight tessellation, the level of these shared edges
has to be identical.
A uniform tessellation rate for an entire subdivision mesh can be set by
using the \f[C]rtcSetTessellationRate\f[] function.
The existance of a level buffer has preference over the uniform
tessellation rate.
.PP
Optionally, the application can fill the sparse edge crease buffers to
make some edges appear sharper.
The edge crease index buffer (\f[C]RTC_EDGE_CREASE_INDEX_BUFFER\f[])
contains an array of pairs of 32\-bit vertex indices that specify
unoriented edges in the geometry topology.
The edge crease weight buffer (\f[C]RTC_EDGE_CREASE_WEIGHT_BUFFER\f[])
stores for each of theses crease edges a positive floating point weight.
The number of edge creases is infered from the size of these buffers,
which has to be identical.
The larger a weight, the sharper the edge.
Specifying a weight of infinity is supported and marks an edge as
infinitely sharp.
Storing an edge multiple times with the same crease weight is allowed,
but has lower performance.
Storing an edge multiple times with different crease weights results in
undefined behavior.
For a stored edge (i,j), the reverse direction edges (j,i) does not have
to get stored, as both are considered the same unoriented edge.
Edge crease features are shared between all topologies.
.PP
Optionally, the application can fill the sparse vertex crease buffers to
make some vertices appear sharper.
The vertex crease index buffer
(\f[C]RTC_VERTEX_CREASE_INDEX_BUFFER\f[]), contains an array of 32\-bit
vertex indices to specify a set of vertices from the geometry topology.
The vertex crease weight buffer
(\f[C]RTC_VERTEX_CREASE_WEIGHT_BUFFER\f[]) specifies for each of these
vertices a positive floating point weight.
The number of vertex creases is infered from the size of these buffers,
and has to be identical.
The larger a weight, the sharper the vertex.
Specifying a weight of infinity is supported and makes the vertex
infinitely sharp.
Storing a vertex multiple times with the same crease weight is allowed,
but has lower performance.
Storing a vertex multiple times with different crease weights results in
undefined behavior.
Vertex crease features are shared between all topologies.
.PP
Subdivision modes can be used to force linear interpolation for some
parts of the subdivision mesh, see
\f[C]rtcSetGeometrySubdivisionMode\f[] for more details.
.SS Parametrization
.PP
The parametrization for subdivision faces are different for
quadrilaterals and non\-quadrilateral faces.
.PP
The parametrization of a quadrilateral face uses the first vertex
\f[C]p0\f[] as base point, and the vector \f[C]p1\ \-\ p0\f[] as
u\-direction and \f[C]p3\ \-\ p0\f[] as v\-direction.
.PP
The parametrization for all other face types (with number of vertices
not equal 4), have a special parametrization where the sub\-patch ID n
(of the n\[aq]th quadrilateral hit that would be obtained by a single
subdivision step) and the local hit location inside this quadrilateral
are encoded in the UV coordinates.
The following code extracts the sub\-patch ID i and local UVs of this
subpatch:
.IP
.nf
\f[C]
const\ unsigned\ int\ l\ =\ floorf(0.5f*U);
const\ unsigned\ int\ h\ =\ floorf(0.5f*V);
const\ unsigned\ int\ i\ =\ 4*h+l;
const\ float\ u\ =\ 2.0f*fracf(0.5f*U)\-0.5f;
const\ float\ v\ =\ 2.0f*fracf(0.5f*V)\-0.5f;
\f[]
.fi
.PP
This encoding allows local subpatch UVs to be in the range
\f[C][\-0.5,1.5[\f[] thus negative subpatch UVs can get passed to
\f[C]rtcInterpolate\f[] to sample subpatches slightly out of bounds.
This can be useful to calculate derivatives using finite differences if
required.
The encoding further has the property that you can just move some value
du (or dv) on a subpatch by adding du (or dv) to the special UV encoding
as long as you are not falling out of the \f[C][\-0.5,1.5[\f[] range.
.PP
To smoothly interpolate vertex attributes over the subdivision surface
we recommend using the \f[C]rtcInterpolate\f[] function, which will
apply the standard subdivision rules for interpolation and automatically
takes care of the special UV encoding for non\-quadrilaterals.
.SS Face\-Varing Data
.PP
Face\-varying interpolation is supported through multiple topologies per
subdivision mesh and binding such topologies to user vertex buffers to
interpolate.
This way texture coordinates may use a different topology with
additional boundaries to construct separate UV regions inside one
subdivision mesh.
.PP
Each such topology \f[C]i\f[] has a separate index buffer
\f[C]RTC_INDEX_BUFFER_(i)\f[] and separate subdivision mode that can get
set using \f[C]rtcSetGeometrySubdivisionMode\f[].
A user vertex buffer \f[C]RTC_USER_VERTEX_BUFFER_(j)\f[] can be assigned
to some topology using the \f[C]rtcSetIndexBuffer\f[] call.
.PP
The face buffer (\f[C]RTC_FACE_BUFFER\f[] type) is shared between all
topologies, which means that the n\[aq]th primitive always has the same
number of vertices (e.g.
being a triangle or a quad) for each topology.
However, the indices of the topologies themselves may be different.
.PP
Also see tutorial [Subdivision Geometry] for an example of how to create
subdivision surfaces.
.SS EXIT STATUS
.PP
On failure \f[C]NULL\f[] is returned and an error code is set that can
get queried using \f[C]rtcDeviceGetError\f[].
.SS SEE ALSO
.PP
[rtcNewGeometry]
